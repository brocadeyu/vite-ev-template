/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./ArcType-f5af12f9","./arrayRemoveDuplicates-91fccd80","./Matrix4-097242f7","./Cartesian3-2da9bb0a","./Cartographic-de64a93a","./ComponentDatatype-322827fe","./defaultValue-4607806f","./Rectangle-86ccddaa","./EllipsoidRhumbLine-ab6a88ae","./GeometryAttribute-7cf0f8d6","./GeometryAttributes-acac33d2","./GeometryPipeline-05a82cb7","./IndexDatatype-3ff1faa7","./Math-6bc63320","./PolygonPipeline-82b233e1","./Transforms-96990627"],(function(e,t,n,i,o,r,a,s,c,l,u,h,p,f,d,y,g){"use strict";function m(){this._array=[],this._offset=0,this._length=0}Object.defineProperties(m.prototype,{length:{get:function(){return this._length}}}),m.prototype.enqueue=function(e){this._array.push(e),this._length++},m.prototype.dequeue=function(){if(0===this._length)return;const e=this._array;let t=this._offset;const n=e[t];return e[t]=void 0,t++,t>10&&2*t>e.length&&(this._array=e.slice(t),t=0),this._offset=t,this._length--,n},m.prototype.peek=function(){if(0!==this._length)return this._array[this._offset]},m.prototype.contains=function(e){return-1!==this._array.indexOf(e)},m.prototype.clear=function(){this._array.length=this._offset=this._length=0},m.prototype.sort=function(e){this._offset>0&&(this._array=this._array.slice(this._offset),this._offset=0),this._array.sort(e)};const C={computeHierarchyPackedLength:function(e,t){let n=0;const i=[e];for(;i.length>0;){const e=i.pop();if(!s.defined(e))continue;n+=2;const o=e.positions,r=e.holes;if(s.defined(o)&&o.length>0&&(n+=o.length*t.packedLength),s.defined(r)){const e=r.length;for(let t=0;t<e;++t)i.push(r[t])}}return n},packPolygonHierarchy:function(e,t,n,i){const o=[e];for(;o.length>0;){const e=o.pop();if(!s.defined(e))continue;const r=e.positions,a=e.holes;if(t[n++]=s.defined(r)?r.length:0,t[n++]=s.defined(a)?a.length:0,s.defined(r)){const e=r.length;for(let o=0;o<e;++o,n+=i.packedLength)i.pack(r[o],t,n)}if(s.defined(a)){const e=a.length;for(let t=0;t<e;++t)o.push(a[t])}}return n},unpackPolygonHierarchy:function(e,t,n){const i=e[t++],o=e[t++],r=new Array(i),a=o>0?new Array(o):void 0;for(let o=0;o<i;++o,t+=n.packedLength)r[o]=n.unpack(e,t);for(let i=0;i<o;++i)a[i]=C.unpackPolygonHierarchy(e,t,n),t=a[i].startingIndex,delete a[i].startingIndex;return{positions:r,holes:a,startingIndex:t}}},b=new i.Cartesian2;function T(e,t,n,o){return i.Cartesian2.subtract(t,e,b),i.Cartesian2.multiplyByScalar(b,n/o,b),i.Cartesian2.add(e,b,b),[b.x,b.y]}const A=new o.Cartesian3;function w(e,t,n,i){return o.Cartesian3.subtract(t,e,A),o.Cartesian3.multiplyByScalar(A,n/i,A),o.Cartesian3.add(e,A,A),[A.x,A.y,A.z]}C.subdivideLineCount=function(e,t,n){const i=o.Cartesian3.distance(e,t)/n,r=Math.max(0,Math.ceil(d.CesiumMath.log2(i)));return Math.pow(2,r)};const x=new r.Cartographic,v=new r.Cartographic,E=new r.Cartographic,L=new o.Cartesian3,P=new l.EllipsoidRhumbLine;C.subdivideRhumbLineCount=function(e,t,n,i){const o=e.cartesianToCartographic(t,x),r=e.cartesianToCartographic(n,v),a=new l.EllipsoidRhumbLine(o,r,e).surfaceDistance/i,s=Math.max(0,Math.ceil(d.CesiumMath.log2(a)));return Math.pow(2,s)},C.subdivideTexcoordLine=function(e,t,n,o,r,a){const s=C.subdivideLineCount(n,o,r),c=i.Cartesian2.distance(e,t),l=c/s,u=a;u.length=2*s;let h=0;for(let n=0;n<s;n++){const i=T(e,t,n*l,c);u[h++]=i[0],u[h++]=i[1]}return u},C.subdivideLine=function(e,t,n,i){const r=C.subdivideLineCount(e,t,n),a=o.Cartesian3.distance(e,t),c=a/r;s.defined(i)||(i=[]);const l=i;l.length=3*r;let u=0;for(let n=0;n<r;n++){const i=w(e,t,n*c,a);l[u++]=i[0],l[u++]=i[1],l[u++]=i[2]}return l},C.subdivideTexcoordRhumbLine=function(e,t,n,o,r,a,s){const c=n.cartesianToCartographic(o,x),l=n.cartesianToCartographic(r,v);P.setEndPoints(c,l);const u=P.surfaceDistance/a,h=Math.max(0,Math.ceil(d.CesiumMath.log2(u))),p=Math.pow(2,h),f=i.Cartesian2.distance(e,t),y=f/p,g=s;g.length=2*p;let m=0;for(let n=0;n<p;n++){const i=T(e,t,n*y,f);g[m++]=i[0],g[m++]=i[1]}return g},C.subdivideRhumbLine=function(e,t,n,i,o){const r=e.cartesianToCartographic(t,x),a=e.cartesianToCartographic(n,v),c=new l.EllipsoidRhumbLine(r,a,e),u=c.surfaceDistance/i,h=Math.max(0,Math.ceil(d.CesiumMath.log2(u))),p=Math.pow(2,h),f=c.surfaceDistance/p;s.defined(o)||(o=[]);const y=o;y.length=3*p;let g=0;for(let t=0;t<p;t++){const n=c.interpolateUsingSurfaceDistance(t*f,E),i=e.cartographicToCartesian(n,L);y[g++]=i.x,y[g++]=i.y,y[g++]=i.z}return y};const I=new o.Cartesian3,M=new o.Cartesian3,D=new o.Cartesian3,_=new o.Cartesian3;C.scaleToGeodeticHeightExtruded=function(e,t,n,i,r){i=s.defaultValue(i,c.Ellipsoid.WGS84);const a=I;let l=M;const u=D;let h=_;if(s.defined(e)&&s.defined(e.attributes)&&s.defined(e.attributes.position)){const s=e.attributes.position.values,c=s.length/2;for(let e=0;e<c;e+=3)o.Cartesian3.fromArray(s,e,u),i.geodeticSurfaceNormal(u,a),h=i.scaleToGeodeticSurface(u,h),l=o.Cartesian3.multiplyByScalar(a,n,l),l=o.Cartesian3.add(h,l,l),s[e+c]=l.x,s[e+1+c]=l.y,s[e+2+c]=l.z,r&&(h=o.Cartesian3.clone(u,h)),l=o.Cartesian3.multiplyByScalar(a,t,l),l=o.Cartesian3.add(h,l,l),s[e]=l.x,s[e+1]=l.y,s[e+2]=l.z}return e},C.polygonOutlinesFromHierarchy=function(e,t,i){const r=[],a=new m;let c,l,u;for(a.enqueue(e);0!==a.length;){const e=a.dequeue();let h=e.positions;if(t)for(u=h.length,c=0;c<u;c++)i.scaleToGeodeticSurface(h[c],h[c]);if(h=n.arrayRemoveDuplicates(h,o.Cartesian3.equalsEpsilon,!0),h.length<3)continue;const p=e.holes?e.holes.length:0;for(c=0;c<p;c++){const h=e.holes[c];let p=h.positions;if(t)for(u=p.length,l=0;l<u;++l)i.scaleToGeodeticSurface(p[l],p[l]);if(p=n.arrayRemoveDuplicates(p,o.Cartesian3.equalsEpsilon,!0),p.length<3)continue;r.push(p);let f=0;for(s.defined(h.holes)&&(f=h.holes.length),l=0;l<f;l++)a.enqueue(h.holes[l])}r.push(h)}return r},C.polygonsFromHierarchy=function(e,t,i,r,a){const c=[],l=[],u=new m;for(u.enqueue(e);0!==u.length;){const e=u.dequeue();let h=e.positions;const p=e.holes;let f,d;if(r)for(d=h.length,f=0;f<d;f++)a.scaleToGeodeticSurface(h[f],h[f]);if(t||(h=n.arrayRemoveDuplicates(h,o.Cartesian3.equalsEpsilon,!0)),h.length<3)continue;let g=i(h);if(!s.defined(g))continue;const m=[];let C=y.PolygonPipeline.computeWindingOrder2D(g);C===y.WindingOrder.CLOCKWISE&&(g.reverse(),h=h.slice().reverse());let b=h.slice();const T=s.defined(p)?p.length:0,A=[];let w;for(f=0;f<T;f++){const e=p[f];let c=e.positions;if(r)for(d=c.length,w=0;w<d;++w)a.scaleToGeodeticSurface(c[w],c[w]);if(t||(c=n.arrayRemoveDuplicates(c,o.Cartesian3.equalsEpsilon,!0)),c.length<3)continue;const l=i(c);if(!s.defined(l))continue;C=y.PolygonPipeline.computeWindingOrder2D(l),C===y.WindingOrder.CLOCKWISE&&(l.reverse(),c=c.slice().reverse()),A.push(c),m.push(b.length),b=b.concat(c),g=g.concat(l);let h=0;for(s.defined(e.holes)&&(h=e.holes.length),w=0;w<h;w++)u.enqueue(e.holes[w])}c.push({outerRing:h,holes:A}),l.push({positions:b,positions2D:g,holes:m})}return{hierarchy:c,polygons:l}};const G=new i.Cartesian2,N=new o.Cartesian3,R=new g.Quaternion,S=new i.Matrix3;C.computeBoundingRectangle=function(e,t,n,r,a){const c=g.Quaternion.fromAxisAngle(e,r,R),l=i.Matrix3.fromQuaternion(c,S);let u=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY,p=Number.POSITIVE_INFINITY,f=Number.NEGATIVE_INFINITY;const d=n.length;for(let e=0;e<d;++e){const r=o.Cartesian3.clone(n[e],N);i.Matrix3.multiplyByVector(l,r,r);const a=t(r,G);s.defined(a)&&(u=Math.min(u,a.x),h=Math.max(h,a.x),p=Math.min(p,a.y),f=Math.max(f,a.y))}return a.x=u,a.y=p,a.width=h-u,a.height=f-p,a},C.createGeometryFromPositions=function(e,n,o,r,c,l,h){let f=y.PolygonPipeline.triangulate(n.positions2D,n.holes);f.length<3&&(f=[0,1,2]);const d=n.positions,g=s.defined(o),m=g?o.positions:void 0;if(c){const e=d.length,t=new Array(3*e);let n=0;for(let i=0;i<e;i++){const e=d[i];t[n++]=e.x,t[n++]=e.y,t[n++]=e.z}const o={attributes:{position:new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:t})},indices:f,primitiveType:u.PrimitiveType.TRIANGLES};g&&(o.attributes.st=new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:i.Cartesian2.packArray(m)}));const r=new u.Geometry(o);return l.normal?p.GeometryPipeline.computeNormal(r):r}return h===t.ArcType.GEODESIC?y.PolygonPipeline.computeSubdivision(e,d,f,m,r):h===t.ArcType.RHUMB?y.PolygonPipeline.computeRhumbLineSubdivision(e,d,f,m,r):h===t.ArcType.NONE?y.PolygonPipeline.computeNonedivision(e,d,f,r):void 0};const O=[],q=[],k=new o.Cartesian3,B=new o.Cartesian3;C.computeWallGeometry=function(e,n,i,r,c,l){let p,y,g,m,b,T,A,w,x,v=e.length,E=0,L=0;const P=s.defined(n),I=P?n.positions:void 0;if(c)for(y=3*v*2,p=new Array(2*y),P&&(x=2*v*2,w=new Array(2*x)),g=0;g<v;g++)m=e[g],b=e[(g+1)%v],p[E]=p[E+y]=m.x,++E,p[E]=p[E+y]=m.y,++E,p[E]=p[E+y]=m.z,++E,p[E]=p[E+y]=b.x,++E,p[E]=p[E+y]=b.y,++E,p[E]=p[E+y]=b.z,++E,P&&(T=I[g],A=I[(g+1)%v],w[L]=w[L+x]=T.x,++L,w[L]=w[L+x]=T.y,++L,w[L]=w[L+x]=A.x,++L,w[L]=w[L+x]=A.y,++L);else{const n=d.CesiumMath.chordLength(r,i.maximumRadius);let a=0;if(l===t.ArcType.GEODESIC)for(g=0;g<v;g++)a+=C.subdivideLineCount(e[g],e[(g+1)%v],n);else if(l===t.ArcType.RHUMB)for(g=0;g<v;g++)a+=C.subdivideRhumbLineCount(i,e[g],e[(g+1)%v],n);else l==t.ArcType.NONE&&(a=v);for(y=3*(a+v),p=new Array(2*y),P&&(x=2*(a+v),w=new Array(2*x)),g=0;g<v;g++){let r,a;m=e[g],b=e[(g+1)%v],P&&(T=I[g],A=I[(g+1)%v]),l===t.ArcType.GEODESIC?(r=C.subdivideLine(m,b,n,q),P&&(a=C.subdivideTexcoordLine(T,A,m,b,n,O))):l===t.ArcType.RHUMB?(r=C.subdivideRhumbLine(i,m,b,n,q),P&&(a=C.subdivideTexcoordRhumbLine(T,A,i,m,b,n,O))):l===t.ArcType.NONE&&(r=new Array(3),o.Cartesian3.packArray([e[g]],r));const s=r.length;for(let e=0;e<s;++e,++E)p[E]=r[e],p[E+y]=r[e];if(p[E]=b.x,p[E+y]=b.x,++E,p[E]=b.y,p[E+y]=b.y,++E,p[E]=b.z,p[E+y]=b.z,++E,P){const e=a.length;for(let t=0;t<e;++t,++L)w[L]=a[t],w[L+x]=a[t];w[L]=A.x,w[L+x]=A.x,++L,w[L]=A.y,w[L+x]=A.y,++L}}}v=p.length;const M=f.IndexDatatype.createTypedArray(v/3,v-6*e.length);let D=0;for(v/=6,g=0;g<v;g++){const e=g,t=e+1,n=e+v,i=n+1;m=o.Cartesian3.fromArray(p,3*e,k),b=o.Cartesian3.fromArray(p,3*t,B),o.Cartesian3.equalsEpsilon(m,b,d.CesiumMath.EPSILON10,d.CesiumMath.EPSILON10)||(M[D++]=e,M[D++]=n,M[D++]=t,M[D++]=t,M[D++]=n,M[D++]=i)}const _={attributes:new h.GeometryAttributes({position:new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:p})}),indices:M,primitiveType:u.PrimitiveType.TRIANGLES};P&&(_.attributes.st=new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:w}));return new u.Geometry(_)},e.PolygonGeometryLibrary=C}));
