/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./Cartesian3-2da9bb0a","./Cartographic-de64a93a","./defaultValue-4607806f","./DeveloperError-46384437","./Rectangle-86ccddaa","./EllipsoidGeodesic-567ed4b0","./EllipsoidRhumbLine-ab6a88ae","./IntersectionTests-fd11e50f","./Math-6bc63320","./Matrix4-097242f7","./Plane-a4827a55"],(function(e,t,a,n,i,r,o,s,c,l,u,h){"use strict";const f={numberOfPoints:function(e,a,n){const i=t.Cartesian3.distance(e,a);return Math.ceil(i/n)},numberOfPointsRhumbLine:function(e,t,a){const n=Math.pow(e.longitude-t.longitude,2)+Math.pow(e.latitude-t.latitude,2);return Math.max(1,Math.ceil(Math.sqrt(n/(a*a))))}},g=new a.Cartographic;f.extractHeights=function(e,t){const a=e.length,n=new Array(a);for(let i=0;i<a;i++){const a=e[i];n[i]=t.cartesianToCartographic(a,g).height}return n};const C=new u.Matrix4,d=new t.Cartesian3,p=new t.Cartesian3,m=new h.Plane(t.Cartesian3.UNIT_X,0),w=new t.Cartesian3,P=new h.Plane(t.Cartesian3.UNIT_X,0),T=new t.Cartesian3,y=new t.Cartesian3,A=[];function b(e,t,a){const n=A;let i;if(n.length=e,t===a){for(i=0;i<e;i++)n[i]=t;return n}const r=(a-t)/e;for(i=0;i<e;i++){const e=t+i*r;n[i]=e}return n}const E=new a.Cartographic,R=new a.Cartographic,M=new t.Cartesian3,S=new t.Cartesian3,D=new t.Cartesian3,x=new o.EllipsoidGeodesic;let N=new s.EllipsoidRhumbLine;function G(e,a,n,i,r,o,s,c){const l=i.scaleToGeodeticSurface(e,S),u=i.scaleToGeodeticSurface(a,D),h=f.numberOfPoints(e,a,n),g=i.cartesianToCartographic(l,E),C=i.cartesianToCartographic(u,R),d=b(h,r,o);x.setEndPoints(g,C);const p=x.surfaceDistance/h;let m=c;g.height=r;let w=i.cartographicToCartesian(g,M);t.Cartesian3.pack(w,s,m),m+=3;for(let e=1;e<h;e++){const a=x.interpolateUsingSurfaceDistance(e*p,R);a.height=d[e],w=i.cartographicToCartesian(a,M),t.Cartesian3.pack(w,s,m),m+=3}return m}function I(e,a,n,i,r,o,c,l){const u=i.cartesianToCartographic(e,E),h=i.cartesianToCartographic(a,R),g=f.numberOfPointsRhumbLine(u,h,n);u.height=0,h.height=0;const C=b(g,r,o);N.ellipsoid.equals(i)||(N=new s.EllipsoidRhumbLine(void 0,void 0,i)),N.setEndPoints(u,h);const d=N.surfaceDistance/g;let p=l;u.height=r;let m=i.cartographicToCartesian(u,M);t.Cartesian3.pack(m,c,p),p+=3;for(let e=1;e<g;e++){const a=N.interpolateUsingSurfaceDistance(e*d,R);a.height=C[e],m=i.cartographicToCartesian(a,M),t.Cartesian3.pack(m,c,p),p+=3}return p}f.wrapLongitude=function(e,a){const i=[],r=[];if(n.defined(e)&&e.length>0){a=n.defaultValue(a,u.Matrix4.IDENTITY);const o=u.Matrix4.inverseTransformation(a,C),s=u.Matrix4.multiplyByPoint(o,t.Cartesian3.ZERO,d),l=t.Cartesian3.normalize(u.Matrix4.multiplyByPointAsVector(o,t.Cartesian3.UNIT_Y,p),p),f=h.Plane.fromPointNormal(s,l,m),g=t.Cartesian3.normalize(u.Matrix4.multiplyByPointAsVector(o,t.Cartesian3.UNIT_X,w),w),A=h.Plane.fromPointNormal(s,g,P);let b=1;i.push(t.Cartesian3.clone(e[0]));let E=i[0];const R=e.length;for(let a=1;a<R;++a){const o=e[a];if(h.Plane.getPointDistance(A,E)<0||h.Plane.getPointDistance(A,o)<0){const e=c.IntersectionTests.lineSegmentPlane(E,o,f,T);if(n.defined(e)){const a=t.Cartesian3.multiplyByScalar(l,5e-9,y);h.Plane.getPointDistance(f,E)<0&&t.Cartesian3.negate(a,a),i.push(t.Cartesian3.add(e,a,new t.Cartesian3)),r.push(b+1),t.Cartesian3.negate(a,a),i.push(t.Cartesian3.add(e,a,new t.Cartesian3)),b=1}}i.push(t.Cartesian3.clone(e[a])),b++,E=o}r.push(b)}return{positions:i,lengths:r}},f.generateArc=function(e){n.defined(e)||(e={});const a=e.positions,i=a.length,o=n.defaultValue(e.ellipsoid,r.Ellipsoid.WGS84);let s=n.defaultValue(e.height,0);const c=Array.isArray(s);if(i<1)return[];if(1===i){const e=o.scaleToGeodeticSurface(a[0],S);if(s=c?s[0]:s,0!==s){const a=o.geodeticSurfaceNormal(e,M);t.Cartesian3.multiplyByScalar(a,s,a),t.Cartesian3.add(e,a,e)}return[e.x,e.y,e.z]}let u=e.minDistance;if(!n.defined(u)){const t=n.defaultValue(e.granularity,l.CesiumMath.RADIANS_PER_DEGREE);u=l.CesiumMath.chordLength(t,o.maximumRadius)}let h,g=0;for(h=0;h<i-1;h++)g+=f.numberOfPoints(a[h],a[h+1],u);const C=3*(g+1),d=new Array(C);let p=0;for(h=0;h<i-1;h++){p=G(a[h],a[h+1],u,o,c?s[h]:s,c?s[h+1]:s,d,p)}A.length=0;const m=a[i-1],w=o.cartesianToCartographic(m,E);w.height=c?s[i-1]:s;const P=o.cartographicToCartesian(w,M);return t.Cartesian3.pack(P,d,C-3),d};const V=new a.Cartographic,k=new a.Cartographic;f.generateRhumbArc=function(e){n.defined(e)||(e={});const i=e.positions,o=i.length,s=n.defaultValue(e.ellipsoid,r.Ellipsoid.WGS84);let c=n.defaultValue(e.height,0);const u=Array.isArray(c);if(o<1)return[];if(1===o){const e=s.scaleToGeodeticSurface(i[0],S);if(c=u?c[0]:c,0!==c){const a=s.geodeticSurfaceNormal(e,M);t.Cartesian3.multiplyByScalar(a,c,a),t.Cartesian3.add(e,a,e)}return[e.x,e.y,e.z]}const h=n.defaultValue(e.granularity,l.CesiumMath.RADIANS_PER_DEGREE);let g,C,d=0,p=s.cartesianToCartographic(i[0],V);for(g=0;g<o-1;g++)C=s.cartesianToCartographic(i[g+1],k),d+=f.numberOfPointsRhumbLine(p,C,h),p=a.Cartographic.clone(C,V);const m=3*(d+1),w=new Array(m);let P=0;for(g=0;g<o-1;g++){P=I(i[g],i[g+1],h,s,u?c[g]:c,u?c[g+1]:c,w,P)}A.length=0;const T=i[o-1],y=s.cartesianToCartographic(T,E);y.height=u?c[o-1]:c;const b=s.cartographicToCartesian(y,M);return t.Cartesian3.pack(b,w,m-3),w},f.generateCartesianArc=function(e){const a=f.generateArc(e),n=a.length/3,i=new Array(n);for(let e=0;e<n;e++)i[e]=t.Cartesian3.unpack(a,3*e);return i},f.generateCartesianRhumbArc=function(e){const a=f.generateRhumbArc(e),n=a.length/3,i=new Array(n);for(let e=0;e<n;e++)i[e]=t.Cartesian3.unpack(a,3*e);return i},e.PolylinePipeline=f}));
