/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./Cartesian3-2da9bb0a","./Cartographic-de64a93a","./defaultValue-4607806f","./DeveloperError-46384437","./Interval-9d0a845c","./Math-6bc63320","./Matrix4-097242f7","./Check-d82b20f7"],(function(t,e,n,a,i,r,s,o,c){"use strict";function u(t,n){n=e.Cartesian3.clone(a.defaultValue(n,e.Cartesian3.ZERO)),e.Cartesian3.equals(n,e.Cartesian3.ZERO)||e.Cartesian3.normalize(n,n),this.origin=e.Cartesian3.clone(a.defaultValue(t,e.Cartesian3.ZERO)),this.direction=n}u.clone=function(t,n){if(a.defined(t))return a.defined(n)?(n.origin=e.Cartesian3.clone(t.origin),n.direction=e.Cartesian3.clone(t.direction),n):new u(t.origin,t.direction)},u.getPoint=function(t,n,i){return a.defined(i)||(i=new e.Cartesian3),i=e.Cartesian3.multiplyByScalar(t.direction,n,i),e.Cartesian3.add(t.origin,i,i)};const l={};function C(t,e,n){const a=t+e;return s.CesiumMath.sign(t)!==s.CesiumMath.sign(e)&&Math.abs(a/Math.max(Math.abs(t),Math.abs(e)))<n?0:a}l.computeDiscriminant=function(t,e,n){return e*e-4*t*n},l.computeRealRoots=function(t,e,n){let a;if(0===t)return 0===e?[]:[-n/e];if(0===e){if(0===n)return[0,0];const e=Math.abs(n),i=Math.abs(t);if(e<i&&e/i<s.CesiumMath.EPSILON14)return[0,0];if(e>i&&i/e<s.CesiumMath.EPSILON14)return[];if(a=-n/t,a<0)return[];const r=Math.sqrt(a);return[-r,r]}if(0===n)return a=-e/t,a<0?[a,0]:[0,a];const i=C(e*e,-(4*t*n),s.CesiumMath.EPSILON14);if(i<0)return[];const r=-.5*C(e,s.CesiumMath.sign(e)*Math.sqrt(i),s.CesiumMath.EPSILON14);return e>0?[r/t,n/r]:[n/r,r/t]};const h={};function M(t,e,n,a){const i=t,r=e/3,s=n/3,o=a,c=i*s,u=r*o,l=r*r,C=s*s,h=i*s-l,M=i*o-r*s,d=r*o-C,f=4*h*d-M*M;let m,g;if(f<0){let t,e,n;l*u>=c*C?(t=i,e=h,n=-2*r*h+i*M):(t=o,e=d,n=-o*M+2*s*d);const a=-(n<0?-1:1)*Math.abs(t)*Math.sqrt(-f);g=-n+a;const p=g/2,w=p<0?-Math.pow(-p,1/3):Math.pow(p,1/3),R=g===a?-w:-e/w;return m=e<=0?w+R:-n/(w*w+R*R+e),l*u>=c*C?[(m-r)/i]:[-o/(m+s)]}const p=h,w=-2*r*h+i*M,R=d,S=-o*M+2*s*d,O=Math.sqrt(f),x=Math.sqrt(3)/2;let y=Math.abs(Math.atan2(i*O,-w)/3);m=2*Math.sqrt(-p);let P=Math.cos(y);g=m*P;let b=m*(-P/2-x*Math.sin(y));const N=g+b>2*r?g-r:b-r,q=i,I=N/q;y=Math.abs(Math.atan2(o*O,-S)/3),m=2*Math.sqrt(-R),P=Math.cos(y),g=m*P,b=m*(-P/2-x*Math.sin(y));const L=-o,E=g+b<2*s?g+s:b+s,z=L/E,v=-N*E-q*L,T=(s*v-r*(N*L))/(-r*v+s*(q*E));return I<=T?I<=z?T<=z?[I,T,z]:[I,z,T]:[z,I,T]:I<=z?[T,I,z]:T<=z?[T,z,I]:[z,T,I]}h.computeDiscriminant=function(t,e,n,a){const i=e*e,r=n*n;return 18*t*e*n*a+i*r-27*(t*t)*(a*a)-4*(t*r*n+i*e*a)},h.computeRealRoots=function(t,e,n,a){let i,r;if(0===t)return l.computeRealRoots(e,n,a);if(0===e){if(0===n){if(0===a)return[0,0,0];r=-a/t;const e=r<0?-Math.pow(-r,1/3):Math.pow(r,1/3);return[e,e,e]}return 0===a?(i=l.computeRealRoots(t,0,n),0===i.Length?[0]:[i[0],0,i[1]]):M(t,0,n,a)}return 0===n?0===a?(r=-e/t,r<0?[r,0,0]:[0,0,r]):M(t,e,0,a):0===a?(i=l.computeRealRoots(t,e,n),0===i.length?[0]:i[1]<=0?[i[0],i[1],0]:i[0]>=0?[0,i[0],i[1]]:[i[0],0,i[1]]):M(t,e,n,a)};const d={};function f(t,e,n,a){const i=t*t,r=e-3*i/8,o=n-e*t/2+i*t/8,c=a-n*t/4+e*i/16-3*i*i/256,u=h.computeRealRoots(1,2*r,r*r-4*c,-o*o);if(u.length>0){const e=-t/4,n=u[u.length-1];if(Math.abs(n)<s.CesiumMath.EPSILON14){const t=l.computeRealRoots(1,r,c);if(2===t.length){const n=t[0],a=t[1];let i;if(n>=0&&a>=0){const t=Math.sqrt(n),i=Math.sqrt(a);return[e-i,e-t,e+t,e+i]}if(n>=0&&a<0)return i=Math.sqrt(n),[e-i,e+i];if(n<0&&a>=0)return i=Math.sqrt(a),[e-i,e+i]}return[]}if(n>0){const t=Math.sqrt(n),a=(r+n-o/t)/2,i=(r+n+o/t)/2,s=l.computeRealRoots(1,t,a),c=l.computeRealRoots(1,-t,i);return 0!==s.length?(s[0]+=e,s[1]+=e,0!==c.length?(c[0]+=e,c[1]+=e,s[1]<=c[0]?[s[0],s[1],c[0],c[1]]:c[1]<=s[0]?[c[0],c[1],s[0],s[1]]:s[0]>=c[0]&&s[1]<=c[1]?[c[0],s[0],s[1],c[1]]:c[0]>=s[0]&&c[1]<=s[1]?[s[0],c[0],c[1],s[1]]:s[0]>c[0]&&s[0]<c[1]?[c[0],s[0],c[1],s[1]]:[s[0],c[0],s[1],c[1]]):s):0!==c.length?(c[0]+=e,c[1]+=e,c):[]}}return[]}function m(t,e,n,a){const i=t*t,r=-2*e,o=n*t+e*e-4*a,c=i*a-n*e*t+n*n,u=h.computeRealRoots(1,r,o,c);if(u.length>0){const r=u[0],o=e-r,c=o*o,C=t/2,h=o/2,M=c-4*a,d=c+4*Math.abs(a),f=i-4*r,m=i+4*Math.abs(r);let g,p,w,R,S,O;if(r<0||M*m<f*d){const e=Math.sqrt(f);g=e/2,p=0===e?0:(t*h-n)/e}else{const e=Math.sqrt(M);g=0===e?0:(t*h-n)/e,p=e/2}0===C&&0===g?(w=0,R=0):s.CesiumMath.sign(C)===s.CesiumMath.sign(g)?(w=C+g,R=r/w):(R=C-g,w=r/R),0===h&&0===p?(S=0,O=0):s.CesiumMath.sign(h)===s.CesiumMath.sign(p)?(S=h+p,O=a/S):(O=h-p,S=a/O);const x=l.computeRealRoots(1,w,S),y=l.computeRealRoots(1,R,O);if(0!==x.length)return 0!==y.length?x[1]<=y[0]?[x[0],x[1],y[0],y[1]]:y[1]<=x[0]?[y[0],y[1],x[0],x[1]]:x[0]>=y[0]&&x[1]<=y[1]?[y[0],x[0],x[1],y[1]]:y[0]>=x[0]&&y[1]<=x[1]?[x[0],y[0],y[1],x[1]]:x[0]>y[0]&&x[0]<y[1]?[y[0],x[0],y[1],x[1]]:[x[0],y[0],x[1],y[1]]:x;if(0!==y.length)return y}return[]}d.computeDiscriminant=function(t,e,n,a,i){const r=t*t,s=e*e,o=s*e,c=n*n,u=c*n,l=a*a,C=l*a,h=i*i;return s*c*l-4*o*C-4*t*u*l+18*t*e*n*C-27*r*l*l+256*(r*t)*(h*i)+i*(18*o*n*a-4*s*u+16*t*c*c-80*t*e*c*a-6*t*s*l+144*r*n*l)+h*(144*t*s*n-27*s*s-128*r*c-192*r*e*a)},d.computeRealRoots=function(t,e,n,a,i){if(Math.abs(t)<s.CesiumMath.EPSILON15)return h.computeRealRoots(e,n,a,i);const r=e/t,o=n/t,c=a/t,u=i/t;let l=r<0?1:0;switch(l+=o<0?l+1:l,l+=c<0?l+1:l,l+=u<0?l+1:l,l){case 0:case 3:case 4:case 6:case 7:case 9:case 10:case 12:case 13:case 14:case 15:return f(r,o,c,u);case 1:case 2:case 5:case 8:case 11:return m(r,o,c,u);default:return}};const g={rayPlane:function(t,n,i){a.defined(i)||(i=new e.Cartesian3);const r=t.origin,o=t.direction,c=n.normal,u=e.Cartesian3.dot(c,o);if(Math.abs(u)<s.CesiumMath.EPSILON15)return;const l=(-n.distance-e.Cartesian3.dot(c,r))/u;return l<0?void 0:(i=e.Cartesian3.multiplyByScalar(o,l,i),e.Cartesian3.add(r,i,i))}},p=new e.Cartesian3,w=new e.Cartesian3,R=new e.Cartesian3,S=new e.Cartesian3,O=new e.Cartesian3;g.rayTriangleParametric=function(t,n,i,r,o){o=a.defaultValue(o,!1);const c=t.origin,u=t.direction,l=e.Cartesian3.subtract(i,n,p),C=e.Cartesian3.subtract(r,n,w),h=e.Cartesian3.cross(u,C,R),M=e.Cartesian3.dot(l,h);let d,f,m,g,x;if(o){if(M<s.CesiumMath.EPSILON6)return;if(d=e.Cartesian3.subtract(c,n,S),m=e.Cartesian3.dot(d,h),m<0||m>M)return;if(f=e.Cartesian3.cross(d,l,O),g=e.Cartesian3.dot(u,f),g<0||m+g>M)return;x=e.Cartesian3.dot(C,f)/M}else{if(Math.abs(M)<s.CesiumMath.EPSILON6)return;const t=1/M;if(d=e.Cartesian3.subtract(c,n,S),m=e.Cartesian3.dot(d,h)*t,m<0||m>1)return;if(f=e.Cartesian3.cross(d,l,O),g=e.Cartesian3.dot(u,f)*t,g<0||m+g>1)return;x=e.Cartesian3.dot(C,f)*t}return x},g.rayTriangle=function(t,n,i,r,s,o){const c=g.rayTriangleParametric(t,n,i,r,s);if(a.defined(c)&&!(c<0))return a.defined(o)||(o=new e.Cartesian3),e.Cartesian3.multiplyByScalar(t.direction,c,o),e.Cartesian3.add(t.origin,o,o)};const x=new u;g.lineSegmentTriangle=function(t,n,i,r,s,o,c){const u=x;e.Cartesian3.clone(t,u.origin),e.Cartesian3.subtract(n,t,u.direction),e.Cartesian3.normalize(u.direction,u.direction);const l=g.rayTriangleParametric(u,i,r,s,o);if(!(!a.defined(l)||l<0||l>e.Cartesian3.distance(t,n)))return a.defined(c)||(c=new e.Cartesian3),e.Cartesian3.multiplyByScalar(u.direction,l,c),e.Cartesian3.add(u.origin,c,c)};const y={root0:0,root1:0};function P(t,n,i){a.defined(i)||(i=new r.Interval);const s=t.origin,o=t.direction,c=n.center,u=n.radius*n.radius,l=e.Cartesian3.subtract(s,c,R),C=function(t,e,n,a){const i=e*e-4*t*n;if(i<0)return;if(i>0){const n=1/(2*t),r=Math.sqrt(i),s=(-e+r)*n,o=(-e-r)*n;return s<o?(a.root0=s,a.root1=o):(a.root0=o,a.root1=s),a}const r=-e/(2*t);return 0!==r?(a.root0=a.root1=r,a):void 0}(e.Cartesian3.dot(o,o),2*e.Cartesian3.dot(o,l),e.Cartesian3.magnitudeSquared(l)-u,y);if(a.defined(C))return i.start=C.root0,i.stop=C.root1,i}g.raySphere=function(t,e,n){if(n=P(t,e,n),a.defined(n)&&!(n.stop<0))return n.start=Math.max(n.start,0),n};const b=new u;g.lineSegmentSphere=function(t,n,i,r){const s=b;e.Cartesian3.clone(t,s.origin);const o=e.Cartesian3.subtract(n,t,s.direction),c=e.Cartesian3.magnitude(o);if(e.Cartesian3.normalize(o,o),r=P(s,i,r),!(!a.defined(r)||r.stop<0||r.start>c))return r.start=Math.max(r.start,0),r.stop=Math.min(r.stop,c),r};const N=new e.Cartesian3,q=new e.Cartesian3;function I(t,e,n){const a=t+e;return s.CesiumMath.sign(t)!==s.CesiumMath.sign(e)&&Math.abs(a/Math.max(Math.abs(t),Math.abs(e)))<n?0:a}g.rayEllipsoid=function(t,n){const a=n.oneOverRadii,i=e.Cartesian3.multiplyComponents(a,t.origin,N),s=e.Cartesian3.multiplyComponents(a,t.direction,q),o=e.Cartesian3.magnitudeSquared(i),c=e.Cartesian3.dot(i,s);let u,l,C,h,M;if(o>1){if(c>=0)return;const t=c*c;if(u=o-1,l=e.Cartesian3.magnitudeSquared(s),C=l*u,t<C)return;if(t>C){h=c*c-C,M=-c+Math.sqrt(h);const t=M/l,e=u/M;return t<e?new r.Interval(t,e):{start:e,stop:t}}const n=Math.sqrt(u/l);return new r.Interval(n,n)}return o<1?(u=o-1,l=e.Cartesian3.magnitudeSquared(s),C=l*u,h=c*c-C,M=-c+Math.sqrt(h),new r.Interval(0,M/l)):c<0?(l=e.Cartesian3.magnitudeSquared(s),new r.Interval(0,-c/l)):void 0};const L=new e.Cartesian3,E=new e.Cartesian3,z=new e.Cartesian3,v=new e.Cartesian3,T=new e.Cartesian3,U=new o.Matrix3,W=new o.Matrix3,B=new o.Matrix3,V=new o.Matrix3,Z=new o.Matrix3,D=new o.Matrix3,A=new o.Matrix3,k=new e.Cartesian3,F=new e.Cartesian3,G=new n.Cartographic;g.grazingAltitudeLocation=function(t,n){const i=t.origin,r=t.direction;if(!e.Cartesian3.equals(i,e.Cartesian3.ZERO)){const t=n.geodeticSurfaceNormal(i,L);if(e.Cartesian3.dot(r,t)>=0)return i}const c=a.defined(this.rayEllipsoid(t,n)),u=n.transformPositionToScaledSpace(r,L),C=e.Cartesian3.normalize(u,u),h=e.Cartesian3.mostOrthogonalAxis(u,v),M=e.Cartesian3.normalize(e.Cartesian3.cross(h,C,E),E),f=e.Cartesian3.normalize(e.Cartesian3.cross(C,M,z),z),m=U;m[0]=C.x,m[1]=C.y,m[2]=C.z,m[3]=M.x,m[4]=M.y,m[5]=M.z,m[6]=f.x,m[7]=f.y,m[8]=f.z;const g=o.Matrix3.transpose(m,W),p=o.Matrix3.fromScale(n.radii,B),w=o.Matrix3.fromScale(n.oneOverRadii,V),R=Z;R[0]=0,R[1]=-r.z,R[2]=r.y,R[3]=r.z,R[4]=0,R[5]=-r.x,R[6]=-r.y,R[7]=r.x,R[8]=0;const S=o.Matrix3.multiply(o.Matrix3.multiply(g,w,D),R,D),O=o.Matrix3.multiply(o.Matrix3.multiply(S,p,A),m,A),x=o.Matrix3.multiplyByVector(S,i,T),y=function(t,n,a,i,r){const c=i*i,u=r*r,C=(t[o.Matrix3.COLUMN1ROW1]-t[o.Matrix3.COLUMN2ROW2])*u,h=r*(i*I(t[o.Matrix3.COLUMN1ROW0],t[o.Matrix3.COLUMN0ROW1],s.CesiumMath.EPSILON15)+n.y),M=t[o.Matrix3.COLUMN0ROW0]*c+t[o.Matrix3.COLUMN2ROW2]*u+i*n.x+a,f=u*I(t[o.Matrix3.COLUMN2ROW1],t[o.Matrix3.COLUMN1ROW2],s.CesiumMath.EPSILON15),m=r*(i*I(t[o.Matrix3.COLUMN2ROW0],t[o.Matrix3.COLUMN0ROW2])+n.z);let g;const p=[];if(0===m&&0===f){if(g=l.computeRealRoots(C,h,M),0===g.length)return p;const t=g[0],n=Math.sqrt(Math.max(1-t*t,0));if(p.push(new e.Cartesian3(i,r*t,r*-n)),p.push(new e.Cartesian3(i,r*t,r*n)),2===g.length){const t=g[1],n=Math.sqrt(Math.max(1-t*t,0));p.push(new e.Cartesian3(i,r*t,r*-n)),p.push(new e.Cartesian3(i,r*t,r*n))}return p}const w=m*m,R=f*f,S=m*f,O=C*C+R,x=2*(h*C+S),y=2*M*C+h*h-R+w,P=2*(M*h-S),b=M*M-w;if(0===O&&0===x&&0===y&&0===P)return p;g=d.computeRealRoots(O,x,y,P,b);const N=g.length;if(0===N)return p;for(let t=0;t<N;++t){const n=g[t],a=n*n,o=Math.max(1-a,0),c=Math.sqrt(o);let u;u=s.CesiumMath.sign(C)===s.CesiumMath.sign(M)?I(C*a+M,h*n,s.CesiumMath.EPSILON12):s.CesiumMath.sign(M)===s.CesiumMath.sign(h*n)?I(C*a,h*n+M,s.CesiumMath.EPSILON12):I(C*a+h*n,M,s.CesiumMath.EPSILON12);const l=u*I(f*n,m,s.CesiumMath.EPSILON15);l<0?p.push(new e.Cartesian3(i,r*n,r*c)):l>0?p.push(new e.Cartesian3(i,r*n,r*-c)):0!==c?(p.push(new e.Cartesian3(i,r*n,r*-c)),p.push(new e.Cartesian3(i,r*n,r*c)),++t):p.push(new e.Cartesian3(i,r*n,r*c))}return p}(O,e.Cartesian3.negate(x,L),0,0,1);let P,b;const N=y.length;if(N>0){let t=e.Cartesian3.clone(e.Cartesian3.ZERO,F),a=Number.NEGATIVE_INFINITY;for(let n=0;n<N;++n){P=o.Matrix3.multiplyByVector(p,o.Matrix3.multiplyByVector(m,y[n],k),k);const s=e.Cartesian3.normalize(e.Cartesian3.subtract(P,i,v),v),c=e.Cartesian3.dot(s,r);c>a&&(a=c,t=e.Cartesian3.clone(P,t))}const u=n.cartesianToCartographic(t,G);return a=s.CesiumMath.clamp(a,0,1),b=e.Cartesian3.magnitude(e.Cartesian3.subtract(t,i,v))*Math.sqrt(1-a*a),b=c?-b:b,u.height=b,n.cartographicToCartesian(u,new e.Cartesian3)}};const Y=new e.Cartesian3;g.lineSegmentPlane=function(t,n,i,r){a.defined(r)||(r=new e.Cartesian3);const o=e.Cartesian3.subtract(n,t,Y),c=i.normal,u=e.Cartesian3.dot(c,o);if(Math.abs(u)<s.CesiumMath.EPSILON6)return;const l=e.Cartesian3.dot(c,t),C=-(i.distance+l)/u;return C<0||C>1?void 0:(e.Cartesian3.multiplyByScalar(o,C,r),e.Cartesian3.add(t,r,r),r)},g.trianglePlaneIntersection=function(t,n,a,i){const r=i.normal,s=i.distance,o=e.Cartesian3.dot(r,t)+s<0,c=e.Cartesian3.dot(r,n)+s<0,u=e.Cartesian3.dot(r,a)+s<0;let l,C,h=0;if(h+=o?1:0,h+=c?1:0,h+=u?1:0,1!==h&&2!==h||(l=new e.Cartesian3,C=new e.Cartesian3),1===h){if(o)return g.lineSegmentPlane(t,n,i,l),g.lineSegmentPlane(t,a,i,C),{positions:[t,n,a,l,C],indices:[0,3,4,1,2,4,1,4,3]};if(c)return g.lineSegmentPlane(n,a,i,l),g.lineSegmentPlane(n,t,i,C),{positions:[t,n,a,l,C],indices:[1,3,4,2,0,4,2,4,3]};if(u)return g.lineSegmentPlane(a,t,i,l),g.lineSegmentPlane(a,n,i,C),{positions:[t,n,a,l,C],indices:[2,3,4,0,1,4,0,4,3]}}else if(2===h){if(!o)return g.lineSegmentPlane(n,t,i,l),g.lineSegmentPlane(a,t,i,C),{positions:[t,n,a,l,C],indices:[1,2,4,1,4,3,0,3,4]};if(!c)return g.lineSegmentPlane(a,n,i,l),g.lineSegmentPlane(t,n,i,C),{positions:[t,n,a,l,C],indices:[2,0,4,2,4,3,1,3,4]};if(!u)return g.lineSegmentPlane(t,a,i,l),g.lineSegmentPlane(n,a,i,C),{positions:[t,n,a,l,C],indices:[0,1,4,0,4,3,2,3,4]}}},t.IntersectionTests=g,t.Ray=u}));
