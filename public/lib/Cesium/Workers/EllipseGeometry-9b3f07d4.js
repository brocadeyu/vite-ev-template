/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./Transforms-96990627","./Matrix4-097242f7","./Cartesian3-2da9bb0a","./Cartographic-de64a93a","./Check-d82b20f7","./ComponentDatatype-322827fe","./defaultValue-4607806f","./DeveloperError-46384437","./EllipseGeometryLibrary-c00bc9e5","./Rectangle-86ccddaa","./GeometryAttribute-7cf0f8d6","./GeometryAttributes-acac33d2","./GeometryInstance-b1135f1b","./GeometryOffsetAttribute-3e5f3e97","./GeometryPipeline-05a82cb7","./IndexDatatype-3ff1faa7","./Math-6bc63320","./VertexFormat-8361ed33"],(function(t,e,i,r,n,o,a,s,l,u,m,c,p,y,d,f,A,h,x){"use strict";const g=new r.Cartesian3,_=new r.Cartesian3,b=new r.Cartesian3,C=new r.Cartesian3,w=new i.Cartesian2,M=new i.Matrix3,E=new i.Matrix3,I=new e.Quaternion,T=new r.Cartesian3,G=new r.Cartesian3,N=new r.Cartesian3,P=new n.Cartographic,v=new r.Cartesian3,V=new i.Cartesian2,F=new i.Cartesian2;function D(t,n,o){const l=n.vertexFormat,m=n.center,y=n.semiMajorAxis,f=n.semiMinorAxis,A=n.ellipsoid,h=n.stRotation,x=o?t.length/3*2:t.length/3,C=n.shadowVolume,D=l.st?new Float32Array(2*x):void 0,O=l.normal?new Float32Array(3*x):void 0,S=l.tangent?new Float32Array(3*x):void 0,L=l.bitangent?new Float32Array(3*x):void 0,R=C?new Float32Array(3*x):void 0;let j=0,k=T,z=G,B=N;const Y=new e.GeographicProjection(A),H=Y.project(A.cartesianToCartographic(m,P),v),U=A.scaleToGeodeticSurface(m,g);A.geodeticSurfaceNormal(U,U);let Q=M,W=E;if(0!==h){let t=e.Quaternion.fromAxisAngle(U,h,I);Q=i.Matrix3.fromQuaternion(t,Q),t=e.Quaternion.fromAxisAngle(U,-h,I),W=i.Matrix3.fromQuaternion(t,W)}else Q=i.Matrix3.clone(i.Matrix3.IDENTITY,Q),W=i.Matrix3.clone(i.Matrix3.IDENTITY,W);const J=i.Cartesian2.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,V),q=i.Cartesian2.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,F);let Z=t.length;const K=o?Z:0,X=K/3*2;for(let e=0;e<Z;e+=3){const n=e+1,a=e+2,s=r.Cartesian3.fromArray(t,e,g);if(l.st){const t=i.Matrix3.multiplyByVector(Q,s,_),e=Y.project(A.cartesianToCartographic(t,P),b);r.Cartesian3.subtract(e,H,e),w.x=(e.x+y)/(2*y),w.y=(e.y+f)/(2*f),J.x=Math.min(w.x,J.x),J.y=Math.min(w.y,J.y),q.x=Math.max(w.x,q.x),q.y=Math.max(w.y,q.y),o&&(D[j+X]=w.x,D[j+1+X]=w.y),D[j++]=w.x,D[j++]=w.y}(l.normal||l.tangent||l.bitangent||C)&&(k=A.geodeticSurfaceNormal(s,k),C&&(R[e+K]=-k.x,R[n+K]=-k.y,R[a+K]=-k.z),(l.normal||l.tangent||l.bitangent)&&((l.tangent||l.bitangent)&&(z=r.Cartesian3.normalize(r.Cartesian3.cross(r.Cartesian3.UNIT_Z,k,z),z),i.Matrix3.multiplyByVector(W,z,z)),l.normal&&(O[e]=k.x,O[n]=k.y,O[a]=k.z,o&&(O[e+K]=-k.x,O[n+K]=-k.y,O[a+K]=-k.z)),l.tangent&&(S[e]=z.x,S[n]=z.y,S[a]=z.z,o&&(S[e+K]=-z.x,S[n+K]=-z.y,S[a+K]=-z.z)),l.bitangent&&(B=r.Cartesian3.normalize(r.Cartesian3.cross(k,z,B),B),L[e]=B.x,L[n]=B.y,L[a]=B.z,o&&(L[e+K]=B.x,L[n+K]=B.y,L[a+K]=B.z))))}if(l.st){Z=D.length;for(let t=0;t<Z;t+=2)D[t]=(D[t]-J.x)/(q.x-J.x),D[t+1]=(D[t+1]-J.y)/(q.y-J.y)}const $=new p.GeometryAttributes;if(l.position){const e=u.EllipseGeometryLibrary.raisePositionsToHeight(t,n,o);$.position=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e})}if(l.st&&($.st=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:D})),l.normal&&($.normal=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:O})),l.tangent&&($.tangent=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:S})),l.bitangent&&($.bitangent=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:L})),C&&($.extrudeDirection=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:R})),o&&s.defined(n.offsetAttribute)){let t=new Uint8Array(x);if(n.offsetAttribute===d.GeometryOffsetAttribute.TOP)t=t.fill(1,0,x/2);else{const e=n.offsetAttribute===d.GeometryOffsetAttribute.NONE?0:1;t=t.fill(e)}$.applyOffset=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return $}function O(t){const e=new Array(t*(t+1)*12-6);let i,r,n,o,a,s=0;for(i=0,n=1,o=0;o<3;o++)e[s++]=n++,e[s++]=i,e[s++]=n;for(o=2;o<t+1;++o){for(n=o*(o+1)-1,i=(o-1)*o-1,e[s++]=n++,e[s++]=i,e[s++]=n,r=2*o,a=0;a<r-1;++a)e[s++]=n,e[s++]=i++,e[s++]=i,e[s++]=n++,e[s++]=i,e[s++]=n;e[s++]=n++,e[s++]=i,e[s++]=n}for(r=2*t,++n,++i,o=0;o<r-1;++o)e[s++]=n,e[s++]=i++,e[s++]=i,e[s++]=n++,e[s++]=i,e[s++]=n;for(e[s++]=n,e[s++]=i++,e[s++]=i,e[s++]=n++,e[s++]=i++,e[s++]=i,++i,o=t-1;o>1;--o){for(e[s++]=i++,e[s++]=i,e[s++]=n,r=2*o,a=0;a<r-1;++a)e[s++]=n,e[s++]=i++,e[s++]=i,e[s++]=n++,e[s++]=i,e[s++]=n;e[s++]=i++,e[s++]=i++,e[s++]=n++}for(o=0;o<3;o++)e[s++]=i++,e[s++]=i,e[s++]=n;return e}let S=new r.Cartesian3;const L=new e.BoundingSphere,R=new e.BoundingSphere;function j(t){const n=t.center,o=t.ellipsoid,l=t.semiMajorAxis;let m=r.Cartesian3.multiplyByScalar(o.geodeticSurfaceNormal(n,g),t.height,g);L.center=r.Cartesian3.add(n,m,L.center),L.radius=l,m=r.Cartesian3.multiplyByScalar(o.geodeticSurfaceNormal(n,m),t.extrudedHeight,m),R.center=r.Cartesian3.add(n,m,R.center),R.radius=l;const h=u.EllipseGeometryLibrary.computeEllipsePositions(t,!0,!0),x=h.positions,E=h.numPts,S=h.outerPositions,j=e.BoundingSphere.union(L,R),k=D(x,t,!0);let z=O(E);const B=z.length;z.length=2*B;const Y=x.length/3;for(let t=0;t<B;t+=3)z[t+B]=z[t+2]+Y,z[t+1+B]=z[t+1]+Y,z[t+2+B]=z[t]+Y;const H=A.IndexDatatype.createTypedArray(2*Y/3,z),U=new c.Geometry({attributes:k,indices:H,primitiveType:c.PrimitiveType.TRIANGLES}),Q=function(t,n){const o=n.vertexFormat,l=n.center,u=n.semiMajorAxis,m=n.semiMinorAxis,y=n.ellipsoid,f=n.height,A=n.extrudedHeight,h=n.stRotation,x=t.length/3*2,E=new Float64Array(3*x),D=o.st?new Float32Array(2*x):void 0,O=o.normal?new Float32Array(3*x):void 0,S=o.tangent?new Float32Array(3*x):void 0,L=o.bitangent?new Float32Array(3*x):void 0,R=n.shadowVolume,j=R?new Float32Array(3*x):void 0;let k=0,z=T,B=G,Y=N;const H=new e.GeographicProjection(y),U=H.project(y.cartesianToCartographic(l,P),v),Q=y.scaleToGeodeticSurface(l,g);y.geodeticSurfaceNormal(Q,Q);const W=e.Quaternion.fromAxisAngle(Q,h,I),J=i.Matrix3.fromQuaternion(W,M),q=i.Cartesian2.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,V),Z=i.Cartesian2.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,F);let K=t.length;const X=K/3*2;for(let e=0;e<K;e+=3){const n=e+1,a=e+2;let s,l=r.Cartesian3.fromArray(t,e,g);if(o.st){const t=i.Matrix3.multiplyByVector(J,l,_),e=H.project(y.cartesianToCartographic(t,P),b);r.Cartesian3.subtract(e,U,e),w.x=(e.x+u)/(2*u),w.y=(e.y+m)/(2*m),q.x=Math.min(w.x,q.x),q.y=Math.min(w.y,q.y),Z.x=Math.max(w.x,Z.x),Z.y=Math.max(w.y,Z.y),D[k+X]=w.x,D[k+1+X]=w.y,D[k++]=w.x,D[k++]=w.y}l=y.scaleToGeodeticSurface(l,l),s=r.Cartesian3.clone(l,_),z=y.geodeticSurfaceNormal(l,z),R&&(j[e+K]=-z.x,j[n+K]=-z.y,j[a+K]=-z.z);let c=r.Cartesian3.multiplyByScalar(z,f,C);if(l=r.Cartesian3.add(l,c,l),c=r.Cartesian3.multiplyByScalar(z,A,c),s=r.Cartesian3.add(s,c,s),o.position&&(E[e+K]=s.x,E[n+K]=s.y,E[a+K]=s.z,E[e]=l.x,E[n]=l.y,E[a]=l.z),o.normal||o.tangent||o.bitangent){Y=r.Cartesian3.clone(z,Y);const i=r.Cartesian3.fromArray(t,(e+3)%K,C);r.Cartesian3.subtract(i,l,i);const u=r.Cartesian3.subtract(s,l,b);z=r.Cartesian3.normalize(r.Cartesian3.cross(u,i,z),z),o.normal&&(O[e]=z.x,O[n]=z.y,O[a]=z.z,O[e+K]=z.x,O[n+K]=z.y,O[a+K]=z.z),o.tangent&&(B=r.Cartesian3.normalize(r.Cartesian3.cross(Y,z,B),B),S[e]=B.x,S[n]=B.y,S[a]=B.z,S[e+K]=B.x,S[e+1+K]=B.y,S[e+2+K]=B.z),o.bitangent&&(L[e]=Y.x,L[n]=Y.y,L[a]=Y.z,L[e+K]=Y.x,L[n+K]=Y.y,L[a+K]=Y.z)}}if(o.st){K=D.length;for(let t=0;t<K;t+=2)D[t]=(D[t]-q.x)/(Z.x-q.x),D[t+1]=(D[t+1]-q.y)/(Z.y-q.y)}const $=new p.GeometryAttributes;if(o.position&&($.position=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:E})),o.st&&($.st=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:D})),o.normal&&($.normal=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:O})),o.tangent&&($.tangent=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:S})),o.bitangent&&($.bitangent=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:L})),R&&($.extrudeDirection=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:j})),s.defined(n.offsetAttribute)){let t=new Uint8Array(x);if(n.offsetAttribute===d.GeometryOffsetAttribute.TOP)t=t.fill(1,0,x/2);else{const e=n.offsetAttribute===d.GeometryOffsetAttribute.NONE?0:1;t=t.fill(e)}$.applyOffset=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:t})}return $}(S,t);z=function(t){const e=t.length/3,i=A.IndexDatatype.createTypedArray(e,6*e);let r=0;for(let t=0;t<e;t++){const n=t,o=t+e,a=(n+1)%e,s=a+e;i[r++]=n,i[r++]=o,i[r++]=a,i[r++]=a,i[r++]=o,i[r++]=s}return i}(S);const W=A.IndexDatatype.createTypedArray(2*S.length/3,z),J=new c.Geometry({attributes:Q,indices:W,primitiveType:c.PrimitiveType.TRIANGLES}),q=f.GeometryPipeline.combineInstances([new y.GeometryInstance({geometry:U}),new y.GeometryInstance({geometry:J})]);return{boundingSphere:j,attributes:q[0].attributes,indices:q[0].indices}}function k(t,e,i,n,o,a,s){const l=u.EllipseGeometryLibrary.computeEllipsePositions({center:t,semiMajorAxis:e,semiMinorAxis:i,rotation:n,granularity:o},!1,!0).outerPositions,c=l.length/3,p=new Array(c);for(let t=0;t<c;++t)p[t]=r.Cartesian3.fromArray(l,3*t);const y=m.Rectangle.fromCartesianArray(p,a,s);return y.width>h.CesiumMath.PI&&(y.north=y.north>0?h.CesiumMath.PI_OVER_TWO-h.CesiumMath.EPSILON7:y.north,y.south=y.south<0?h.CesiumMath.EPSILON7-h.CesiumMath.PI_OVER_TWO:y.south,y.east=h.CesiumMath.PI,y.west=-h.CesiumMath.PI),y}function z(t){const e=(t=s.defaultValue(t,s.defaultValue.EMPTY_OBJECT)).center,i=s.defaultValue(t.ellipsoid,m.Ellipsoid.WGS84),n=t.semiMajorAxis,o=t.semiMinorAxis,a=s.defaultValue(t.granularity,h.CesiumMath.RADIANS_PER_DEGREE),l=s.defaultValue(t.vertexFormat,x.VertexFormat.DEFAULT),u=s.defaultValue(t.height,0),c=s.defaultValue(t.extrudedHeight,u);this._center=r.Cartesian3.clone(e),this._semiMajorAxis=n,this._semiMinorAxis=o,this._ellipsoid=m.Ellipsoid.clone(i),this._rotation=s.defaultValue(t.rotation,0),this._stRotation=s.defaultValue(t.stRotation,0),this._height=Math.max(c,u),this._granularity=a,this._vertexFormat=x.VertexFormat.clone(l),this._extrudedHeight=Math.min(c,u),this._shadowVolume=s.defaultValue(t.shadowVolume,!1),this._workerName="createEllipseGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0}z.packedLength=r.Cartesian3.packedLength+m.Ellipsoid.packedLength+x.VertexFormat.packedLength+9,z.pack=function(t,e,i){return i=s.defaultValue(i,0),r.Cartesian3.pack(t._center,e,i),i+=r.Cartesian3.packedLength,m.Ellipsoid.pack(t._ellipsoid,e,i),i+=m.Ellipsoid.packedLength,x.VertexFormat.pack(t._vertexFormat,e,i),i+=x.VertexFormat.packedLength,e[i++]=t._semiMajorAxis,e[i++]=t._semiMinorAxis,e[i++]=t._rotation,e[i++]=t._stRotation,e[i++]=t._height,e[i++]=t._granularity,e[i++]=t._extrudedHeight,e[i++]=t._shadowVolume?1:0,e[i]=s.defaultValue(t._offsetAttribute,-1),e};const B=new r.Cartesian3,Y=new m.Ellipsoid,H=new x.VertexFormat,U={center:B,ellipsoid:Y,vertexFormat:H,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,stRotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};z.unpack=function(t,e,i){e=s.defaultValue(e,0);const n=r.Cartesian3.unpack(t,e,B);e+=r.Cartesian3.packedLength;const o=m.Ellipsoid.unpack(t,e,Y);e+=m.Ellipsoid.packedLength;const a=x.VertexFormat.unpack(t,e,H);e+=x.VertexFormat.packedLength;const l=t[e++],u=t[e++],c=t[e++],p=t[e++],y=t[e++],d=t[e++],f=t[e++],A=1===t[e++],h=t[e];return s.defined(i)?(i._center=r.Cartesian3.clone(n,i._center),i._ellipsoid=m.Ellipsoid.clone(o,i._ellipsoid),i._vertexFormat=x.VertexFormat.clone(a,i._vertexFormat),i._semiMajorAxis=l,i._semiMinorAxis=u,i._rotation=c,i._stRotation=p,i._height=y,i._granularity=d,i._extrudedHeight=f,i._shadowVolume=A,i._offsetAttribute=-1===h?void 0:h,i):(U.height=y,U.extrudedHeight=f,U.granularity=d,U.stRotation=p,U.rotation=c,U.semiMajorAxis=l,U.semiMinorAxis=u,U.shadowVolume=A,U.offsetAttribute=-1===h?void 0:h,new z(U))},z.computeRectangle=function(t,e){const i=(t=s.defaultValue(t,s.defaultValue.EMPTY_OBJECT)).center,r=s.defaultValue(t.ellipsoid,m.Ellipsoid.WGS84),n=t.semiMajorAxis,o=t.semiMinorAxis,a=s.defaultValue(t.granularity,h.CesiumMath.RADIANS_PER_DEGREE);return k(i,n,o,s.defaultValue(t.rotation,0),a,r,e)},z.createGeometry=function(t){if(t._semiMajorAxis<=0||t._semiMinorAxis<=0)return;const i=t._height,n=t._extrudedHeight,o=!h.CesiumMath.equalsEpsilon(i,n,0,h.CesiumMath.EPSILON2);t._center=t._ellipsoid.scaleToGeodeticSurface(t._center,t._center);const l={center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:t._ellipsoid,rotation:t._rotation,height:i,granularity:t._granularity,vertexFormat:t._vertexFormat,stRotation:t._stRotation};let m;if(o)l.extrudedHeight=n,l.shadowVolume=t._shadowVolume,l.offsetAttribute=t._offsetAttribute,m=j(l);else if(m=function(t){const i=t.center;S=r.Cartesian3.multiplyByScalar(t.ellipsoid.geodeticSurfaceNormal(i,S),t.height,S),S=r.Cartesian3.add(i,S,S);const n=new e.BoundingSphere(S,t.semiMajorAxis),o=u.EllipseGeometryLibrary.computeEllipsePositions(t,!0,!1),a=o.positions,s=o.numPts,l=D(a,t,!1);let m=O(s);return m=A.IndexDatatype.createTypedArray(a.length/3,m),{boundingSphere:n,attributes:l,indices:m}}(l),s.defined(t._offsetAttribute)){const e=m.attributes.position.values.length,i=t._offsetAttribute===d.GeometryOffsetAttribute.NONE?0:1,r=new Uint8Array(e/3).fill(i);m.attributes.applyOffset=new c.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}return new c.Geometry({attributes:m.attributes,indices:m.indices,primitiveType:c.PrimitiveType.TRIANGLES,boundingSphere:m.boundingSphere,offsetAttribute:t._offsetAttribute})},z.createShadowVolume=function(t,e,i){const r=t._granularity,n=t._ellipsoid,o=e(r,n),a=i(r,n);return new z({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,ellipsoid:n,rotation:t._rotation,stRotation:t._stRotation,granularity:r,extrudedHeight:o,height:a,vertexFormat:x.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(z.prototype,{rectangle:{get:function(){return s.defined(this._rectangle)||(this._rectangle=k(this._center,this._semiMajorAxis,this._semiMinorAxis,this._rotation,this._granularity,this._ellipsoid)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return s.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){const e=-t._stRotation;if(0===e)return[0,0,0,1,1,0];const i=u.EllipseGeometryLibrary.computeEllipsePositions({center:t._center,semiMajorAxis:t._semiMajorAxis,semiMinorAxis:t._semiMinorAxis,rotation:t._rotation,granularity:t._granularity},!1,!0).outerPositions,n=i.length/3,o=new Array(n);for(let t=0;t<n;++t)o[t]=r.Cartesian3.fromArray(i,3*t);const a=t._ellipsoid,s=t.rectangle;return c.Geometry._textureCoordinateRotationPoints(o,e,a,s)}(this)),this._textureCoordinateRotationPoints}}}),t.EllipseGeometry=z}));
