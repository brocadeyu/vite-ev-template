/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./Transforms-96990627","./Matrix4-097242f7","./Cartesian3-2da9bb0a","./Cartographic-de64a93a","./Check-d82b20f7","./defaultValue-4607806f","./DeveloperError-46384437","./Rectangle-86ccddaa","./EllipsoidTangentPlane-7a711ff7","./Interval-9d0a845c","./Math-6bc63320","./Plane-a4827a55"],(function(a,t,e,n,r,i,s,o,c,C,u,l,d){"use strict";function h(a,t){this.center=n.Cartesian3.clone(s.defaultValue(a,n.Cartesian3.ZERO)),this.halfAxes=e.Matrix3.clone(s.defaultValue(t,e.Matrix3.ZERO))}h.packedLength=n.Cartesian3.packedLength+e.Matrix3.packedLength,h.pack=function(a,t,r){return r=s.defaultValue(r,0),n.Cartesian3.pack(a.center,t,r),e.Matrix3.pack(a.halfAxes,t,r+n.Cartesian3.packedLength),t},h.unpack=function(a,t,r){return t=s.defaultValue(t,0),s.defined(r)||(r=new h),n.Cartesian3.unpack(a,t,r.center),e.Matrix3.unpack(a,t+n.Cartesian3.packedLength,r.halfAxes),r};const x=new n.Cartesian3,m=new n.Cartesian3,f=new n.Cartesian3,M=new n.Cartesian3,p=new n.Cartesian3,w=new n.Cartesian3,g=new e.Matrix3,b={unitary:new e.Matrix3,diagonal:new e.Matrix3};h.fromPoints=function(a,t){if(s.defined(t)||(t=new h),!s.defined(a)||0===a.length)return t.halfAxes=e.Matrix3.ZERO,t.center=n.Cartesian3.ZERO,t;let r;const i=a.length,o=n.Cartesian3.clone(a[0],x);for(r=1;r<i;r++)n.Cartesian3.add(o,a[r],o);const c=1/i;n.Cartesian3.multiplyByScalar(o,c,o);let C,u=0,l=0,d=0,y=0,N=0,T=0;for(r=0;r<i;r++)C=n.Cartesian3.subtract(a[r],o,m),u+=C.x*C.x,l+=C.x*C.y,d+=C.x*C.z,y+=C.y*C.y,N+=C.y*C.z,T+=C.z*C.z;u*=c,l*=c,d*=c,y*=c,N*=c,T*=c;const O=g;O[0]=u,O[1]=l,O[2]=d,O[3]=l,O[4]=y,O[5]=N,O[6]=d,O[7]=N,O[8]=T;const A=e.Matrix3.computeEigenDecomposition(O,b),P=e.Matrix3.clone(A.unitary,t.halfAxes);let I=e.Matrix3.getColumn(P,0,M),R=e.Matrix3.getColumn(P,1,p),E=e.Matrix3.getColumn(P,2,w),S=-Number.MAX_VALUE,U=-Number.MAX_VALUE,L=-Number.MAX_VALUE,z=Number.MAX_VALUE,B=Number.MAX_VALUE,V=Number.MAX_VALUE;for(r=0;r<i;r++)C=a[r],S=Math.max(n.Cartesian3.dot(I,C),S),U=Math.max(n.Cartesian3.dot(R,C),U),L=Math.max(n.Cartesian3.dot(E,C),L),z=Math.min(n.Cartesian3.dot(I,C),z),B=Math.min(n.Cartesian3.dot(R,C),B),V=Math.min(n.Cartesian3.dot(E,C),V);I=n.Cartesian3.multiplyByScalar(I,.5*(z+S),I),R=n.Cartesian3.multiplyByScalar(R,.5*(B+U),R),E=n.Cartesian3.multiplyByScalar(E,.5*(V+L),E);const _=n.Cartesian3.add(I,R,t.center);n.Cartesian3.add(_,E,_);const k=f;return k.x=S-z,k.y=U-B,k.z=L-V,n.Cartesian3.multiplyByScalar(k,.5,k),e.Matrix3.multiplyByScale(t.halfAxes,k,t.halfAxes),t};const y=new n.Cartesian3,N=new n.Cartesian3;function T(a,t,r,i,o,c,C,u,l,d,x){s.defined(x)||(x=new h);const m=x.halfAxes;e.Matrix3.setColumn(m,0,t,m),e.Matrix3.setColumn(m,1,r,m),e.Matrix3.setColumn(m,2,i,m);let f=y;f.x=(o+c)/2,f.y=(C+u)/2,f.z=(l+d)/2;const M=N;M.x=(c-o)/2,M.y=(u-C)/2,M.z=(d-l)/2;const p=x.center;return f=e.Matrix3.multiplyByVector(m,f,f),n.Cartesian3.add(a,f,p),e.Matrix3.multiplyByScale(m,M,m),x}const O=new r.Cartographic,A=new n.Cartesian3,P=new r.Cartographic,I=new r.Cartographic,R=new r.Cartographic,E=new r.Cartographic,S=new r.Cartographic,U=new n.Cartesian3,L=new n.Cartesian3,z=new n.Cartesian3,B=new n.Cartesian3,V=new n.Cartesian3,_=new e.Cartesian2,k=new e.Cartesian2,W=new e.Cartesian2,D=new e.Cartesian2,X=new e.Cartesian2,q=new n.Cartesian3,j=new n.Cartesian3,v=new n.Cartesian3,Z=new n.Cartesian3,Y=new e.Cartesian2,G=new n.Cartesian3,F=new n.Cartesian3,H=new n.Cartesian3,J=new d.Plane(n.Cartesian3.UNIT_X,0);h.fromRectangle=function(a,t,e,i,o){let u,h,x,m,f,M,p;if(t=s.defaultValue(t,0),e=s.defaultValue(e,0),i=s.defaultValue(i,c.Ellipsoid.WGS84),a.width<=l.CesiumMath.PI){const n=c.Rectangle.center(a,O),s=i.cartographicToCartesian(n,A),l=new C.EllipsoidTangentPlane(s,i);p=l.plane;const w=n.longitude,g=a.south<0&&a.north>0?0:n.latitude,b=r.Cartographic.fromRadians(w,a.north,e,P),y=r.Cartographic.fromRadians(a.west,a.north,e,I),N=r.Cartographic.fromRadians(a.west,g,e,R),q=r.Cartographic.fromRadians(a.west,a.south,e,E),j=r.Cartographic.fromRadians(w,a.south,e,S),v=i.cartographicToCartesian(b,U);let Z=i.cartographicToCartesian(y,L);const Y=i.cartographicToCartesian(N,z);let G=i.cartographicToCartesian(q,B);const F=i.cartographicToCartesian(j,V),H=l.projectPointToNearestOnPlane(v,_),J=l.projectPointToNearestOnPlane(Z,k),K=l.projectPointToNearestOnPlane(Y,W),Q=l.projectPointToNearestOnPlane(G,D),$=l.projectPointToNearestOnPlane(F,X);return u=Math.min(J.x,K.x,Q.x),h=-u,m=Math.max(J.y,H.y),x=Math.min(Q.y,$.y),y.height=q.height=t,Z=i.cartographicToCartesian(y,L),G=i.cartographicToCartesian(q,B),f=Math.min(d.Plane.getPointDistance(p,Z),d.Plane.getPointDistance(p,G)),M=e,T(l.origin,l.xAxis,l.yAxis,l.zAxis,u,h,x,m,f,M,o)}const w=a.south>0,g=a.north<0,b=w?a.south:g?a.north:0,y=c.Rectangle.center(a,O).longitude,N=n.Cartesian3.fromRadians(y,b,e,i,q);N.z=0;const K=Math.abs(N.x)<l.CesiumMath.EPSILON10&&Math.abs(N.y)<l.CesiumMath.EPSILON10?n.Cartesian3.UNIT_X:n.Cartesian3.normalize(N,j),Q=n.Cartesian3.UNIT_Z,$=n.Cartesian3.cross(K,Q,v);p=d.Plane.fromPointNormal(N,K,J);const aa=n.Cartesian3.fromRadians(y+l.CesiumMath.PI_OVER_TWO,b,e,i,Z);h=n.Cartesian3.dot(d.Plane.projectPointOntoPlane(p,aa,Y),$),u=-h,m=n.Cartesian3.fromRadians(0,a.north,g?t:e,i,G).z,x=n.Cartesian3.fromRadians(0,a.south,w?t:e,i,F).z;const ta=n.Cartesian3.fromRadians(a.east,b,e,i,H);return f=d.Plane.getPointDistance(p,ta),M=0,T(N,$,Q,K,u,h,x,m,f,M,o)},h.fromTransformation=function(a,t){return s.defined(t)||(t=new h),t.center=e.Matrix4.getTranslation(a,t.center),t.halfAxes=e.Matrix4.getMatrix3(a,t.halfAxes),t.halfAxes=e.Matrix3.multiplyByScalar(t.halfAxes,.5,t.halfAxes),t},h.clone=function(a,t){if(s.defined(a))return s.defined(t)?(n.Cartesian3.clone(a.center,t.center),e.Matrix3.clone(a.halfAxes,t.halfAxes),t):new h(a.center,a.halfAxes)},h.intersectPlane=function(a,r){const i=a.center,s=r.normal,o=a.halfAxes,c=s.x,C=s.y,u=s.z,l=Math.abs(c*o[e.Matrix3.COLUMN0ROW0]+C*o[e.Matrix3.COLUMN0ROW1]+u*o[e.Matrix3.COLUMN0ROW2])+Math.abs(c*o[e.Matrix3.COLUMN1ROW0]+C*o[e.Matrix3.COLUMN1ROW1]+u*o[e.Matrix3.COLUMN1ROW2])+Math.abs(c*o[e.Matrix3.COLUMN2ROW0]+C*o[e.Matrix3.COLUMN2ROW1]+u*o[e.Matrix3.COLUMN2ROW2]),d=n.Cartesian3.dot(s,i)+r.distance;return d<=-l?t.Intersect.OUTSIDE:d>=l?t.Intersect.INSIDE:t.Intersect.INTERSECTING};const K=new n.Cartesian3,Q=new n.Cartesian3,$=new n.Cartesian3,aa=new n.Cartesian3,ta=new n.Cartesian3,ea=new n.Cartesian3;h.distanceSquaredTo=function(a,t){const r=n.Cartesian3.subtract(t,a.center,y),i=a.halfAxes;let s=e.Matrix3.getColumn(i,0,K),o=e.Matrix3.getColumn(i,1,Q),c=e.Matrix3.getColumn(i,2,$);const C=n.Cartesian3.magnitude(s),u=n.Cartesian3.magnitude(o),d=n.Cartesian3.magnitude(c);let h=!0,x=!0,m=!0;C>0?n.Cartesian3.divideByScalar(s,C,s):h=!1,u>0?n.Cartesian3.divideByScalar(o,u,o):x=!1,d>0?n.Cartesian3.divideByScalar(c,d,c):m=!1;const f=!h+!x+!m;let M,p,w;if(1===f){let a=s;M=o,p=c,x?m||(a=c,p=s):(a=o,M=s),w=n.Cartesian3.cross(M,p,ta),a===s?s=w:a===o?o=w:a===c&&(c=w)}else if(2===f){M=s,x?M=o:m&&(M=c);let a=n.Cartesian3.UNIT_Y;a.equalsEpsilon(M,l.CesiumMath.EPSILON3)&&(a=n.Cartesian3.UNIT_X),p=n.Cartesian3.cross(M,a,aa),n.Cartesian3.normalize(p,p),w=n.Cartesian3.cross(M,p,ta),n.Cartesian3.normalize(w,w),M===s?(o=p,c=w):M===o?(c=p,s=w):M===c&&(s=p,o=w)}else 3===f&&(s=n.Cartesian3.UNIT_X,o=n.Cartesian3.UNIT_Y,c=n.Cartesian3.UNIT_Z);const g=ea;g.x=n.Cartesian3.dot(r,s),g.y=n.Cartesian3.dot(r,o),g.z=n.Cartesian3.dot(r,c);let b,N=0;return g.x<-C?(b=g.x+C,N+=b*b):g.x>C&&(b=g.x-C,N+=b*b),g.y<-u?(b=g.y+u,N+=b*b):g.y>u&&(b=g.y-u,N+=b*b),g.z<-d?(b=g.z+d,N+=b*b):g.z>d&&(b=g.z-d,N+=b*b),N};const na=new n.Cartesian3,ra=new n.Cartesian3;h.computePlaneDistances=function(a,t,r,i){s.defined(i)||(i=new u.Interval);let o=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY;const C=a.center,l=a.halfAxes,d=e.Matrix3.getColumn(l,0,K),h=e.Matrix3.getColumn(l,1,Q),x=e.Matrix3.getColumn(l,2,$),m=n.Cartesian3.add(d,h,na);n.Cartesian3.add(m,x,m),n.Cartesian3.add(m,C,m);const f=n.Cartesian3.subtract(m,t,ra);let M=n.Cartesian3.dot(r,f);return o=Math.min(M,o),c=Math.max(M,c),n.Cartesian3.add(C,d,m),n.Cartesian3.add(m,h,m),n.Cartesian3.subtract(m,x,m),n.Cartesian3.subtract(m,t,f),M=n.Cartesian3.dot(r,f),o=Math.min(M,o),c=Math.max(M,c),n.Cartesian3.add(C,d,m),n.Cartesian3.subtract(m,h,m),n.Cartesian3.add(m,x,m),n.Cartesian3.subtract(m,t,f),M=n.Cartesian3.dot(r,f),o=Math.min(M,o),c=Math.max(M,c),n.Cartesian3.add(C,d,m),n.Cartesian3.subtract(m,h,m),n.Cartesian3.subtract(m,x,m),n.Cartesian3.subtract(m,t,f),M=n.Cartesian3.dot(r,f),o=Math.min(M,o),c=Math.max(M,c),n.Cartesian3.subtract(C,d,m),n.Cartesian3.add(m,h,m),n.Cartesian3.add(m,x,m),n.Cartesian3.subtract(m,t,f),M=n.Cartesian3.dot(r,f),o=Math.min(M,o),c=Math.max(M,c),n.Cartesian3.subtract(C,d,m),n.Cartesian3.add(m,h,m),n.Cartesian3.subtract(m,x,m),n.Cartesian3.subtract(m,t,f),M=n.Cartesian3.dot(r,f),o=Math.min(M,o),c=Math.max(M,c),n.Cartesian3.subtract(C,d,m),n.Cartesian3.subtract(m,h,m),n.Cartesian3.add(m,x,m),n.Cartesian3.subtract(m,t,f),M=n.Cartesian3.dot(r,f),o=Math.min(M,o),c=Math.max(M,c),n.Cartesian3.subtract(C,d,m),n.Cartesian3.subtract(m,h,m),n.Cartesian3.subtract(m,x,m),n.Cartesian3.subtract(m,t,f),M=n.Cartesian3.dot(r,f),o=Math.min(M,o),c=Math.max(M,c),i.start=o,i.stop=c,i};const ia=new n.Cartesian3,sa=new n.Cartesian3,oa=new n.Cartesian3;h.computeCorners=function(a,t){s.defined(t)||(t=[new n.Cartesian3,new n.Cartesian3,new n.Cartesian3,new n.Cartesian3,new n.Cartesian3,new n.Cartesian3,new n.Cartesian3,new n.Cartesian3]);const r=a.center,i=a.halfAxes,o=e.Matrix3.getColumn(i,0,ia),c=e.Matrix3.getColumn(i,1,sa),C=e.Matrix3.getColumn(i,2,oa);return n.Cartesian3.clone(r,t[0]),n.Cartesian3.subtract(t[0],o,t[0]),n.Cartesian3.subtract(t[0],c,t[0]),n.Cartesian3.subtract(t[0],C,t[0]),n.Cartesian3.clone(r,t[1]),n.Cartesian3.subtract(t[1],o,t[1]),n.Cartesian3.subtract(t[1],c,t[1]),n.Cartesian3.add(t[1],C,t[1]),n.Cartesian3.clone(r,t[2]),n.Cartesian3.subtract(t[2],o,t[2]),n.Cartesian3.add(t[2],c,t[2]),n.Cartesian3.subtract(t[2],C,t[2]),n.Cartesian3.clone(r,t[3]),n.Cartesian3.subtract(t[3],o,t[3]),n.Cartesian3.add(t[3],c,t[3]),n.Cartesian3.add(t[3],C,t[3]),n.Cartesian3.clone(r,t[4]),n.Cartesian3.add(t[4],o,t[4]),n.Cartesian3.subtract(t[4],c,t[4]),n.Cartesian3.subtract(t[4],C,t[4]),n.Cartesian3.clone(r,t[5]),n.Cartesian3.add(t[5],o,t[5]),n.Cartesian3.subtract(t[5],c,t[5]),n.Cartesian3.add(t[5],C,t[5]),n.Cartesian3.clone(r,t[6]),n.Cartesian3.add(t[6],o,t[6]),n.Cartesian3.add(t[6],c,t[6]),n.Cartesian3.subtract(t[6],C,t[6]),n.Cartesian3.clone(r,t[7]),n.Cartesian3.add(t[7],o,t[7]),n.Cartesian3.add(t[7],c,t[7]),n.Cartesian3.add(t[7],C,t[7]),t};const ca=new e.Matrix3;h.computeTransformation=function(a,t){s.defined(t)||(t=new e.Matrix4);const n=a.center,r=e.Matrix3.multiplyByUniformScale(a.halfAxes,2,ca);return e.Matrix4.fromRotationTranslation(r,n,t)};const Ca=new t.BoundingSphere;h.isOccluded=function(a,e){const n=t.BoundingSphere.fromOrientedBoundingBox(a,Ca);return!e.isBoundingSphereVisible(n)},h.prototype.intersectPlane=function(a){return h.intersectPlane(this,a)},h.prototype.distanceSquaredTo=function(a){return h.distanceSquaredTo(this,a)},h.prototype.computePlaneDistances=function(a,t,e){return h.computePlaneDistances(this,a,t,e)},h.prototype.computeCorners=function(a){return h.computeCorners(this,a)},h.prototype.computeTransformation=function(a){return h.computeTransformation(this,a)},h.prototype.isOccluded=function(a){return h.isOccluded(this,a)},h.equals=function(a,t){return a===t||s.defined(a)&&s.defined(t)&&n.Cartesian3.equals(a.center,t.center)&&e.Matrix3.equals(a.halfAxes,t.halfAxes)},h.prototype.clone=function(a){return h.clone(this,a)},h.prototype.equals=function(a){return h.equals(this,a)},a.OrientedBoundingBox=h}));
