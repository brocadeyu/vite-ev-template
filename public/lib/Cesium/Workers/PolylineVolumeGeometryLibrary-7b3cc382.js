/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./Matrix4-097242f7","./Cartesian3-2da9bb0a","./Cartographic-de64a93a","./EllipsoidTangentPlane-7a711ff7","./Math-6bc63320","./PolylinePipeline-26d2ab82","./Transforms-96990627","./defaultValue-4607806f","./DeveloperError-46384437"],(function(e,a,t,n,r,i,s,o,l,c){"use strict";var C=Object.freeze({ROUNDED:0,MITERED:1,BEVELED:2,EV_ARC:3});const u={};function d(e,a){l.defined(u[e])||(u[e]=!0,console.warn(l.defaultValue(a,e)))}d.geometryOutlines="Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.",d.geometryZIndex="Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored",d.geometryHeightReference="Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored",d.geometryExtrudedHeightReference="Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored";const g=[new t.Cartesian3,new t.Cartesian3],y=new t.Cartesian3,f=new t.Cartesian3,h=new t.Cartesian3,m=new t.Cartesian3,p=new t.Cartesian3,w=new t.Cartesian3,x=new t.Cartesian3,E=new t.Cartesian3,P=new t.Cartesian3,b=new t.Cartesian3,M=new t.Cartesian3,T={};let B=new n.Cartographic;function z(e,a,n,r){const i=e[0],s=e[1],o=t.Cartesian3.angleBetween(i,s),l=Math.ceil(o/r),c=new Array(l);let C;if(a===n){for(C=0;C<l;C++)c[C]=a;return c.push(n),c}const u=(n-a)/l;for(C=1;C<l;C++){const e=a+C*u;c[C]=e}return c[0]=a,c.push(n),c}const A=new t.Cartesian3,S=new t.Cartesian3;const D=new t.Cartesian3(-1,0,0);let R=new a.Matrix4;const O=new a.Matrix4;let V=new a.Matrix3;const I=a.Matrix3.IDENTITY.clone(),v=new t.Cartesian3,N=new a.Cartesian4,G=new t.Cartesian3;function H(e,n,i,s,l,c,C,u){let d=v,g=N;R=o.Transforms.eastNorthUpToFixedFrame(e,l,R),d=a.Matrix4.multiplyByPointAsVector(R,D,d),d=t.Cartesian3.normalize(d,d);const y=function(e,n,i,s){const o=new r.EllipsoidTangentPlane(i,s),l=o.projectPointOntoPlane(t.Cartesian3.add(i,e,A),A),c=o.projectPointOntoPlane(t.Cartesian3.add(i,n,S),S),C=a.Cartesian2.angleBetween(l,c);return c.x*l.y-c.y*l.x>=0?-C:C}(d,n,e,l);V=a.Matrix3.fromRotationZ(y,V),G.z=c,R=a.Matrix4.multiplyTransformation(R,a.Matrix4.fromRotationTranslation(V,G,O),R);const f=I;f[0]=C;for(let e=0;e<u;e++)for(let e=0;e<i.length;e+=3)g=t.Cartesian3.fromArray(i,e,g),g=a.Matrix3.multiplyByVector(f,g,g),g=a.Matrix4.multiplyByPoint(R,g,g),s.push(g.x,g.y,g.z);return s}const L=new t.Cartesian3;function j(e,a,n,r,i,s,o){for(let l=0;l<e.length;l+=3){r=H(t.Cartesian3.fromArray(e,l,L),a,n,r,i,s[l/3],o,1)}return r}function Q(e,a){const t=e.length,n=new Array(3*t);let r=0;const i=a.x+a.width/2,s=a.y+a.height/2;for(let a=0;a<t;a++)n[r++]=e[a].x-i,n[r++]=0,n[r++]=e[a].y-s;return n}const q=new o.Quaternion,F=new t.Cartesian3,U=new a.Matrix3;function _(e,n,r,s,l,c,u,d,g,y){const f=t.Cartesian3.angleBetween(t.Cartesian3.subtract(n,e,b),t.Cartesian3.subtract(r,e,M)),h=s===C.BEVELED?0:Math.ceil(f/i.CesiumMath.toRadians(5));let m,p,w;if(m=l?a.Matrix3.fromQuaternion(o.Quaternion.fromAxisAngle(t.Cartesian3.negate(e,b),f/(h+1),q),U):a.Matrix3.fromQuaternion(o.Quaternion.fromAxisAngle(e,f/(h+1),q),U),n=t.Cartesian3.clone(n,F),h>0){const r=y?2:1;for(let i=0;i<h;i++)n=a.Matrix3.multiplyByVector(m,n,n),p=t.Cartesian3.subtract(n,e,b),p=t.Cartesian3.normalize(p,p),l||(p=t.Cartesian3.negate(p,p)),w=c.scaleToGeodeticSurface(n,M),u=H(w,p,d,u,c,g,1,r)}else p=t.Cartesian3.subtract(n,e,b),p=t.Cartesian3.normalize(p,p),l||(p=t.Cartesian3.negate(p,p)),w=c.scaleToGeodeticSurface(n,M),u=H(w,p,d,u,c,g,1,1),r=t.Cartesian3.clone(r,F),p=t.Cartesian3.subtract(r,e,b),p=t.Cartesian3.normalize(p,p),l||(p=t.Cartesian3.negate(p,p)),w=c.scaleToGeodeticSurface(r,M),u=H(w,p,d,u,c,g,1,1);return u}T.removeDuplicatesFromShape=function(e){const t=e.length,n=[];for(let r=t-1,i=0;i<t;r=i++){const t=e[r],s=e[i];a.Cartesian2.equals(t,s)||n.push(s)}return n},T.angleIsGreaterThanPi=function(e,a,n,i){const s=new r.EllipsoidTangentPlane(n,i),o=s.projectPointOntoPlane(t.Cartesian3.add(n,e,A),A),l=s.projectPointOntoPlane(t.Cartesian3.add(n,a,S),S);return l.x*o.y-l.y*o.x>=0};const Z=new t.Cartesian3,W=new t.Cartesian3;T.computePositions=function(e,a,n,r,o){const l=r._ellipsoid,c=function(e,a){const t=new Array(e.length);for(let n=0;n<e.length;n++){const r=e[n];B=a.cartesianToCartographic(r,B),t[n]=B.height,e[n]=a.scaleToGeodeticSurface(r,r)}return t}(e,l),u=r._granularity,M=r._cornerType,A=o?function(e,a){const t=e.length,n=new Array(6*t);let r=0;const i=a.x+a.width/2,s=a.y+a.height/2;let o=e[0];n[r++]=o.x-i,n[r++]=0,n[r++]=o.y-s;for(let a=1;a<t;a++){o=e[a];const t=o.x-i,l=o.y-s;n[r++]=t,n[r++]=0,n[r++]=l,n[r++]=t,n[r++]=0,n[r++]=l}return o=e[0],n[r++]=o.x-i,n[r++]=0,n[r++]=o.y-s,n}(a,n):Q(a,n),S=o?Q(a,n):void 0,D=n.height/2,R=n.width/2;let O=e.length,V=[],I=o?[]:void 0,v=y,N=f,G=h,L=m,q=p,F=w,U=x,Y=E,k=P,J=e[0],K=e[1];L=l.geodeticSurfaceNormal(J,L),v=t.Cartesian3.subtract(K,J,v),v=t.Cartesian3.normalize(v,v),Y=t.Cartesian3.cross(L,v,Y),Y=t.Cartesian3.normalize(Y,Y);let X,$,ee=c[0],ae=c[1];o&&(I=H(J,Y,S,I,l,ee+D,1,1)),k=t.Cartesian3.clone(J,k),J=K,N=t.Cartesian3.negate(v,N);for(let a=1;a<O-1;a++){const n=o?2:1;if(K=e[a+1],J.equals(K)){d("Positions are too close and are considered equivalent with rounding error.");continue}v=t.Cartesian3.subtract(K,J,v),v=t.Cartesian3.normalize(v,v),G=t.Cartesian3.add(v,N,G),G=t.Cartesian3.normalize(G,G),L=l.geodeticSurfaceNormal(J,L);const r=t.Cartesian3.multiplyByScalar(L,t.Cartesian3.dot(v,L),Z);t.Cartesian3.subtract(v,r,r),t.Cartesian3.normalize(r,r);const y=t.Cartesian3.multiplyByScalar(L,t.Cartesian3.dot(N,L),W);t.Cartesian3.subtract(N,y,y),t.Cartesian3.normalize(y,y);if(!i.CesiumMath.equalsEpsilon(Math.abs(t.Cartesian3.dot(r,y)),1,i.CesiumMath.EPSILON7)){G=t.Cartesian3.cross(G,L,G),G=t.Cartesian3.cross(L,G,G),G=t.Cartesian3.normalize(G,G);const e=1/Math.max(.25,t.Cartesian3.magnitude(t.Cartesian3.cross(G,N,b))),a=T.angleIsGreaterThanPi(v,N,J,l);a?(q=t.Cartesian3.add(J,t.Cartesian3.multiplyByScalar(G,e*R,G),q),F=t.Cartesian3.add(q,t.Cartesian3.multiplyByScalar(Y,R,F),F),g[0]=t.Cartesian3.clone(k,g[0]),g[1]=t.Cartesian3.clone(F,g[1]),X=z(g,ee+D,ae+D,u),$=s.PolylinePipeline.generateArc({positions:g,granularity:u,ellipsoid:l}),V=j($,Y,A,V,l,X,1),Y=t.Cartesian3.cross(L,v,Y),Y=t.Cartesian3.normalize(Y,Y),U=t.Cartesian3.add(q,t.Cartesian3.multiplyByScalar(Y,R,U),U),M===C.ROUNDED||M===C.BEVELED?_(q,F,U,M,a,l,V,A,ae+D,o):(G=t.Cartesian3.negate(G,G),V=H(J,G,A,V,l,ae+D,e,n)),k=t.Cartesian3.clone(U,k)):(q=t.Cartesian3.add(J,t.Cartesian3.multiplyByScalar(G,e*R,G),q),F=t.Cartesian3.add(q,t.Cartesian3.multiplyByScalar(Y,-R,F),F),g[0]=t.Cartesian3.clone(k,g[0]),g[1]=t.Cartesian3.clone(F,g[1]),X=z(g,ee+D,ae+D,u),$=s.PolylinePipeline.generateArc({positions:g,granularity:u,ellipsoid:l}),V=j($,Y,A,V,l,X,1),Y=t.Cartesian3.cross(L,v,Y),Y=t.Cartesian3.normalize(Y,Y),U=t.Cartesian3.add(q,t.Cartesian3.multiplyByScalar(Y,-R,U),U),M===C.ROUNDED||M===C.BEVELED?_(q,F,U,M,a,l,V,A,ae+D,o):V=H(J,G,A,V,l,ae+D,e,n),k=t.Cartesian3.clone(U,k)),N=t.Cartesian3.negate(v,N)}else V=H(k,Y,A,V,l,ee+D,1,1),k=J;ee=ae,ae=c[a+1],J=K}g[0]=t.Cartesian3.clone(k,g[0]),g[1]=t.Cartesian3.clone(J,g[1]),X=z(g,ee+D,ae+D,u),$=s.PolylinePipeline.generateArc({positions:g,granularity:u,ellipsoid:l}),V=j($,Y,A,V,l,X,1),o&&(I=H(J,Y,S,I,l,ae+D,1,1)),O=V.length;const te=o?O+I.length:O,ne=new Float64Array(te);return ne.set(V),o&&ne.set(I,O),ne},e.CornerType=C,e.PolylineVolumeGeometryLibrary=T,e.oneTimeWarning=d}));
