/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./AttributeCompression-a11efab2","./Matrix4-097242f7","./Cartesian3-2da9bb0a","./Check-d82b20f7","./defaultValue-4607806f","./Math-6bc63320","./Transforms-96990627","./Cartographic-de64a93a","./ComponentDatatype-322827fe","./DeveloperError-46384437","./EncodedCartesian3-818af823","./GeometryAttribute-7cf0f8d6","./IndexDatatype-3ff1faa7","./IntersectionTests-fd11e50f","./Plane-a4827a55"],(function(e,t,n,i,r,a,s,o,u,c,l,p,d,f,y,m){"use strict";const C=new i.Cartesian3,h=new i.Cartesian3,v=new i.Cartesian3;const b={calculateACMR:function(e){const t=(e=a.defaultValue(e,a.defaultValue.EMPTY_OBJECT)).indices;let n=e.maximumIndex;const i=a.defaultValue(e.cacheSize,24),r=t.length;if(!a.defined(n)){n=0;let e=0,i=t[e];for(;e<r;)i>n&&(n=i),++e,i=t[e]}const s=[];for(let e=0;e<n+1;e++)s[e]=0;let o=i+1;for(let e=0;e<r;++e)o-s[t[e]]>i&&(s[t[e]]=o,++o);return(o-i+1)/(r/3)}};b.tipsify=function(e){const t=(e=a.defaultValue(e,a.defaultValue.EMPTY_OBJECT)).indices,n=e.maximumIndex,i=a.defaultValue(e.cacheSize,24);let r;function s(e,t,n,i,a,s,o){let u,c=-1,l=-1,p=0;for(;p<n.length;){const e=n[p];i[e].numLiveTriangles&&(u=0,a-i[e].timeStamp+2*i[e].numLiveTriangles<=t&&(u=a-i[e].timeStamp),(u>l||-1===l)&&(l=u,c=e)),++p}return-1===c?function(e,t,n,i){for(;t.length>=1;){const n=t[t.length-1];if(t.splice(t.length-1,1),e[n].numLiveTriangles>0)return n}for(;r<i;){if(e[r].numLiveTriangles>0)return++r,r-1;++r}return-1}(i,s,0,o):c}const o=t.length;let u=0,c=0,l=t[c];const p=o;if(a.defined(n))u=n+1;else{for(;c<p;)l>u&&(u=l),++c,l=t[c];if(-1===u)return 0;++u}const d=[];let f;for(f=0;f<u;f++)d[f]={numLiveTriangles:0,timeStamp:0,vertexTriangles:[]};c=0;let y=0;for(;c<p;)d[t[c]].vertexTriangles.push(y),++d[t[c]].numLiveTriangles,d[t[c+1]].vertexTriangles.push(y),++d[t[c+1]].numLiveTriangles,d[t[c+2]].vertexTriangles.push(y),++d[t[c+2]].numLiveTriangles,++y,c+=3;let m=0,C=i+1;r=1;let h=[];const v=[];let b,g,A=0;const T=[],x=o/3,P=[];for(f=0;f<x;f++)P[f]=!1;let w,S;for(;-1!==m;){h=[],g=d[m],S=g.vertexTriangles.length;for(let e=0;e<S;++e)if(y=g.vertexTriangles[e],!P[y]){P[y]=!0,c=y+y+y;for(let e=0;e<3;++e)w=t[c],h.push(w),v.push(w),T[A]=w,++A,b=d[w],--b.numLiveTriangles,C-b.timeStamp>i&&(b.timeStamp=C,++C),++c}m=s(0,i,h,d,C,v,u)}return T};const g={};function A(e,t,n,i,r){e[t++]=n,e[t++]=i,e[t++]=i,e[t++]=r,e[t++]=r,e[t]=n}function T(e){const t={};for(const n in e)if(e.hasOwnProperty(n)&&a.defined(e[n])&&a.defined(e[n].values)){const i=e[n];t[n]=new d.GeometryAttribute({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return t}function x(e,t,n){for(const i in t)if(t.hasOwnProperty(i)&&a.defined(t[i])&&a.defined(t[i].values)){const r=t[i];for(let t=0;t<r.componentsPerAttribute;++t)e[i].values.push(r.values[n*r.componentsPerAttribute+t])}}g.toWireframe=function(e){const t=e.indices;if(a.defined(t)){switch(e.primitiveType){case d.PrimitiveType.TRIANGLES:e.indices=function(e){const t=e.length,n=t/3*6,i=f.IndexDatatype.createTypedArray(t,n);let r=0;for(let n=0;n<t;n+=3,r+=6)A(i,r,e[n],e[n+1],e[n+2]);return i}(t);break;case d.PrimitiveType.TRIANGLE_STRIP:e.indices=function(e){const t=e.length;if(t>=3){const n=6*(t-2),i=f.IndexDatatype.createTypedArray(t,n);A(i,0,e[0],e[1],e[2]);let r=6;for(let n=3;n<t;++n,r+=6)A(i,r,e[n-1],e[n],e[n-2]);return i}return new Uint16Array}(t);break;case d.PrimitiveType.TRIANGLE_FAN:e.indices=function(e){if(e.length>0){const t=e.length-1,n=6*(t-1),i=f.IndexDatatype.createTypedArray(t,n),r=e[0];let a=0;for(let n=1;n<t;++n,a+=6)A(i,a,r,e[n],e[n+1]);return i}return new Uint16Array}(t)}e.primitiveType=d.PrimitiveType.LINES}return e},g.createLineSegmentsForVectors=function(e,t,n){t=a.defaultValue(t,"normal"),n=a.defaultValue(n,1e4);const i=e.attributes.position.values,r=e.attributes[t].values,s=i.length,u=new Float64Array(2*s);let l,p=0;for(let e=0;e<s;e+=3)u[p++]=i[e],u[p++]=i[e+1],u[p++]=i[e+2],u[p++]=i[e]+r[e]*n,u[p++]=i[e+1]+r[e+1]*n,u[p++]=i[e+2]+r[e+2]*n;const f=e.boundingSphere;return a.defined(f)&&(l=new o.BoundingSphere(f.center,f.radius+n)),new d.Geometry({attributes:{position:new d.GeometryAttribute({componentDatatype:c.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:u})},primitiveType:d.PrimitiveType.LINES,boundingSphere:l})},g.createAttributeLocations=function(e){const t=["position","positionHigh","positionLow","position3DHigh","position3DLow","position2DHigh","position2DLow","pickColor","normal","st","tangent","bitangent","extrudeDirection","compressedAttributes"],n=e.attributes,i={};let r,s=0;const o=t.length;for(r=0;r<o;++r){const e=t[r];a.defined(n[e])&&(i[e]=s++)}for(const e in n)n.hasOwnProperty(e)&&!a.defined(i[e])&&(i[e]=s++);return i},g.reorderForPreVertexCache=function(e){const t=d.Geometry.computeNumberOfVertices(e),n=e.indices;if(a.defined(n)){const i=new Int32Array(t);for(let e=0;e<t;e++)i[e]=-1;const r=n,s=r.length,o=f.IndexDatatype.createTypedArray(t,s);let u,l=0,p=0,d=0;for(;l<s;)u=i[r[l]],-1!==u?o[p]=u:(u=r[l],i[u]=d,o[p]=d,++d),++l,++p;e.indices=o;const y=e.attributes;for(const e in y)if(y.hasOwnProperty(e)&&a.defined(y[e])&&a.defined(y[e].values)){const n=y[e],r=n.values;let a=0;const s=n.componentsPerAttribute,o=c.ComponentDatatype.createTypedArray(n.componentDatatype,d*s);for(;a<t;){const e=i[a];if(-1!==e)for(let t=0;t<s;t++)o[s*e+t]=r[s*a+t];++a}n.values=o}}return e},g.reorderForPostVertexCache=function(e,t){const n=e.indices;if(e.primitiveType===d.PrimitiveType.TRIANGLES&&a.defined(n)){const i=n.length;let r=0;for(let e=0;e<i;e++)n[e]>r&&(r=n[e]);e.indices=b.tipsify({indices:n,maximumIndex:r,cacheSize:t})}return e},g.fitToUnsignedShortIndices=function(e){const t=[],n=d.Geometry.computeNumberOfVertices(e);if(a.defined(e.indices)&&n>=s.CesiumMath.SIXTY_FOUR_KILOBYTES){let n=[],i=[],r=0,o=T(e.attributes);const u=e.indices,c=u.length;let l;e.primitiveType===d.PrimitiveType.TRIANGLES?l=3:e.primitiveType===d.PrimitiveType.LINES?l=2:e.primitiveType===d.PrimitiveType.POINTS&&(l=1);for(let p=0;p<c;p+=l){for(let t=0;t<l;++t){const s=u[p+t];let c=n[s];a.defined(c)||(c=r++,n[s]=c,x(o,e.attributes,s)),i.push(c)}r+l>=s.CesiumMath.SIXTY_FOUR_KILOBYTES&&(t.push(new d.Geometry({attributes:o,indices:i,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV})),n=[],i=[],r=0,o=T(e.attributes))}0!==i.length&&t.push(new d.Geometry({attributes:o,indices:i,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV}))}else t.push(e);return t};const P=new i.Cartesian3,w=new u.Cartographic;g.projectTo2D=function(e,t,n,r,s){const u=e.attributes[t],l=(s=a.defined(s)?s:new o.GeographicProjection).ellipsoid,p=u.values,f=new Float64Array(p.length);let y=0;for(let e=0;e<p.length;e+=3){const t=i.Cartesian3.fromArray(p,e,P),n=l.cartesianToCartographic(t,w),r=s.project(n,P);f[y++]=r.x,f[y++]=r.y,f[y++]=r.z}return e.attributes[n]=u,e.attributes[r]=new d.GeometryAttribute({componentDatatype:c.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:f}),delete e.attributes[t],e};const S={high:0,low:0};g.encodeAttribute=function(e,t,n,i){const r=e.attributes[t],a=r.values,s=a.length,o=new Float32Array(s),u=new Float32Array(s);for(let e=0;e<s;++e)p.EncodedCartesian3.encode(a[e],S),o[e]=S.high,u[e]=S.low;const l=r.componentsPerAttribute;return e.attributes[n]=new d.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:l,values:o}),e.attributes[i]=new d.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:l,values:u}),delete e.attributes[t],e};let I=new i.Cartesian3;function O(e,t){if(a.defined(t)){const r=t.values,a=r.length;for(let t=0;t<a;t+=3)i.Cartesian3.unpack(r,t,I),n.Matrix4.multiplyByPoint(e,I,I),i.Cartesian3.pack(I,r,t)}}function E(e,t){if(a.defined(t)){const r=t.values,a=r.length;for(let t=0;t<a;t+=3)i.Cartesian3.unpack(r,t,I),n.Matrix3.multiplyByVector(e,I,I),I=i.Cartesian3.normalize(I,I),i.Cartesian3.pack(I,r,t)}}const N=new n.Matrix4,L=new n.Matrix3;g.transformToWorldCoordinates=function(e){const t=e.modelMatrix;if(n.Matrix4.equals(t,n.Matrix4.IDENTITY))return e;const i=e.geometry.attributes;O(t,i.position),O(t,i.prevPosition),O(t,i.nextPosition),(a.defined(i.normal)||a.defined(i.tangent)||a.defined(i.bitangent))&&(n.Matrix4.inverse(t,N),n.Matrix4.transpose(N,N),n.Matrix4.getMatrix3(N,L),E(L,i.normal),E(L,i.tangent),E(L,i.bitangent));const r=e.geometry.boundingSphere;return a.defined(r)&&(e.geometry.boundingSphere=o.BoundingSphere.transform(r,t,r)),e.modelMatrix=n.Matrix4.clone(n.Matrix4.IDENTITY),e};const D=new i.Cartesian3;function z(e,t){const n=e.length;let r,s,u,l;e[0].modelMatrix;const p=a.defined(e[0][t].indices),y=e[0][t].primitiveType,m=function(e,t){const n=e.length,i={},r=e[0][t].attributes;let s;for(s in r)if(r.hasOwnProperty(s)&&a.defined(r[s])&&a.defined(r[s].values)){const o=r[s];let u=o.values.length,l=!0;for(let i=1;i<n;++i){const n=e[i][t].attributes[s];if(!a.defined(n)||o.componentDatatype!==n.componentDatatype||o.componentsPerAttribute!==n.componentsPerAttribute||o.normalize!==n.normalize){l=!1;break}u+=n.values.length}l&&(i[s]=new d.GeometryAttribute({componentDatatype:o.componentDatatype,componentsPerAttribute:o.componentsPerAttribute,normalize:o.normalize,values:c.ComponentDatatype.createTypedArray(o.componentDatatype,u)}))}return i}(e,t);let C,h,v,b;for(r in m)if(m.hasOwnProperty(r))for(C=m[r].values,l=0,s=0;s<n;++s)for(h=e[s][t].attributes[r].values,v=h.length,u=0;u<v;++u)C[l++]=h[u];if(p){let i=0;for(s=0;s<n;++s)i+=e[s][t].indices.length;const r=d.Geometry.computeNumberOfVertices(new d.Geometry({attributes:m,primitiveType:d.PrimitiveType.POINTS})),a=f.IndexDatatype.createTypedArray(r,i);let o=0,u=0;for(s=0;s<n;++s){const n=e[s][t].indices,i=n.length;for(l=0;l<i;++l)a[o++]=u+n[l];u+=d.Geometry.computeNumberOfVertices(e[s][t])}b=a}let g,A=new i.Cartesian3,T=0;for(s=0;s<n;++s){if(g=e[s][t].boundingSphere,!a.defined(g)){A=void 0;break}i.Cartesian3.add(g.center,A,A)}if(a.defined(A))for(i.Cartesian3.divideByScalar(A,n,A),s=0;s<n;++s){g=e[s][t].boundingSphere;const n=i.Cartesian3.magnitude(i.Cartesian3.subtract(g.center,A,D))+g.radius;n>T&&(T=n)}return new d.Geometry({attributes:m,indices:b,primitiveType:y,boundingSphere:a.defined(A)?new o.BoundingSphere(A,T):void 0})}g.combineInstances=function(e){const t=[],n=[],i=e.length;for(let r=0;r<i;++r){const i=e[r];a.defined(i.geometry)?t.push(i):a.defined(i.westHemisphereGeometry)&&a.defined(i.eastHemisphereGeometry)&&n.push(i)}const r=[];return t.length>0&&r.push(z(t,"geometry")),n.length>0&&(r.push(z(n,"westHemisphereGeometry")),r.push(z(n,"eastHemisphereGeometry"))),r};const M=new i.Cartesian3,G=new i.Cartesian3,V=new i.Cartesian3,R=new i.Cartesian3;g.computeNormal=function(e){const t=e.indices,n=e.attributes,r=n.position.values,a=n.position.values.length/3,o=t.length,u=new Array(a),l=new Array(o/3),p=new Array(o);let f;for(f=0;f<a;f++)u[f]={indexOffset:0,count:0,currentCount:0};let y=0;for(f=0;f<o;f+=3){const e=t[f],n=t[f+1],a=t[f+2],s=3*e,o=3*n,c=3*a;G.x=r[s],G.y=r[s+1],G.z=r[s+2],V.x=r[o],V.y=r[o+1],V.z=r[o+2],R.x=r[c],R.y=r[c+1],R.z=r[c+2],u[e].count++,u[n].count++,u[a].count++,i.Cartesian3.subtract(V,G,V),i.Cartesian3.subtract(R,G,R),l[y]=i.Cartesian3.cross(V,R,new i.Cartesian3),y++}let m,C=0;for(f=0;f<a;f++)u[f].indexOffset+=C,C+=u[f].count;for(y=0,f=0;f<o;f+=3){m=u[t[f]];let e=m.indexOffset+m.currentCount;p[e]=y,m.currentCount++,m=u[t[f+1]],e=m.indexOffset+m.currentCount,p[e]=y,m.currentCount++,m=u[t[f+2]],e=m.indexOffset+m.currentCount,p[e]=y,m.currentCount++,y++}const h=new Float32Array(3*a);for(f=0;f<a;f++){const e=3*f;if(m=u[f],i.Cartesian3.clone(i.Cartesian3.ZERO,M),m.count>0){for(y=0;y<m.count;y++)i.Cartesian3.add(M,l[p[m.indexOffset+y]],M);i.Cartesian3.equalsEpsilon(i.Cartesian3.ZERO,M,s.CesiumMath.EPSILON10)&&i.Cartesian3.clone(l[p[m.indexOffset]],M)}i.Cartesian3.equalsEpsilon(i.Cartesian3.ZERO,M,s.CesiumMath.EPSILON10)&&(M.z=1),i.Cartesian3.normalize(M,M),h[e]=M.x,h[e+1]=M.y,h[e+2]=M.z}return e.attributes.normal=new d.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:h}),e};const F=new i.Cartesian3,B=new i.Cartesian3,k=new i.Cartesian3;g.computeTangentAndBitangent=function(e){e.attributes;const t=e.indices,n=e.attributes.position.values,r=e.attributes.normal.values,a=e.attributes.st.values,s=e.attributes.position.values.length/3,o=t.length,u=new Array(3*s);let l,p,f,y;for(l=0;l<u.length;l++)u[l]=0;for(l=0;l<o;l+=3){const e=t[l],i=t[l+1],r=t[l+2];p=3*e,f=3*i,y=3*r;const s=2*e,o=2*i,c=2*r,d=n[p],m=n[p+1],C=n[p+2],h=a[s],v=a[s+1],b=a[o+1]-v,g=a[c+1]-v,A=1/((a[o]-h)*g-(a[c]-h)*b),T=(g*(n[f]-d)-b*(n[y]-d))*A,x=(g*(n[f+1]-m)-b*(n[y+1]-m))*A,P=(g*(n[f+2]-C)-b*(n[y+2]-C))*A;u[p]+=T,u[p+1]+=x,u[p+2]+=P,u[f]+=T,u[f+1]+=x,u[f+2]+=P,u[y]+=T,u[y+1]+=x,u[y+2]+=P}const m=new Float32Array(3*s),C=new Float32Array(3*s);for(l=0;l<s;l++){p=3*l,f=p+1,y=p+2;const e=i.Cartesian3.fromArray(r,p,F),t=i.Cartesian3.fromArray(u,p,k),n=i.Cartesian3.dot(e,t);i.Cartesian3.multiplyByScalar(e,n,B),i.Cartesian3.normalize(i.Cartesian3.subtract(t,B,t),t),m[p]=t.x,m[f]=t.y,m[y]=t.z,i.Cartesian3.normalize(i.Cartesian3.cross(e,t,t),t),C[p]=t.x,C[f]=t.y,C[y]=t.z}return e.attributes.tangent=new d.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:m}),e.attributes.bitangent=new d.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C}),e};const _=new n.Cartesian2,q=new i.Cartesian3,U=new i.Cartesian3,Y=new i.Cartesian3;let Z=new n.Cartesian2;function H(e){switch(e.primitiveType){case d.PrimitiveType.TRIANGLE_FAN:return function(e){const t=d.Geometry.computeNumberOfVertices(e),n=f.IndexDatatype.createTypedArray(t,3*(t-2));n[0]=1,n[1]=0,n[2]=2;let i=3;for(let e=3;e<t;++e)n[i++]=e-1,n[i++]=0,n[i++]=e;return e.indices=n,e.primitiveType=d.PrimitiveType.TRIANGLES,e}(e);case d.PrimitiveType.TRIANGLE_STRIP:return function(e){const t=d.Geometry.computeNumberOfVertices(e),n=f.IndexDatatype.createTypedArray(t,3*(t-2));n[0]=0,n[1]=1,n[2]=2,t>3&&(n[3]=0,n[4]=2,n[5]=3);let i=6;for(let e=3;e<t-1;e+=2)n[i++]=e,n[i++]=e-1,n[i++]=e+1,e+2<t&&(n[i++]=e,n[i++]=e+1,n[i++]=e+2);return e.indices=n,e.primitiveType=d.PrimitiveType.TRIANGLES,e}(e);case d.PrimitiveType.TRIANGLES:return function(e){if(a.defined(e.indices))return e;const t=d.Geometry.computeNumberOfVertices(e),n=f.IndexDatatype.createTypedArray(t,t);for(let e=0;e<t;++e)n[e]=e;return e.indices=n,e}(e);case d.PrimitiveType.LINE_STRIP:return function(e){const t=d.Geometry.computeNumberOfVertices(e),n=f.IndexDatatype.createTypedArray(t,2*(t-1));n[0]=0,n[1]=1;let i=2;for(let e=2;e<t;++e)n[i++]=e-1,n[i++]=e;return e.indices=n,e.primitiveType=d.PrimitiveType.LINES,e}(e);case d.PrimitiveType.LINE_LOOP:return function(e){const t=d.Geometry.computeNumberOfVertices(e),n=f.IndexDatatype.createTypedArray(t,2*t);n[0]=0,n[1]=1;let i=2;for(let e=2;e<t;++e)n[i++]=e-1,n[i++]=e;return n[i++]=t-1,n[i]=0,e.indices=n,e.primitiveType=d.PrimitiveType.LINES,e}(e);case d.PrimitiveType.LINES:return function(e){if(a.defined(e.indices))return e;const t=d.Geometry.computeNumberOfVertices(e),n=f.IndexDatatype.createTypedArray(t,t);for(let e=0;e<t;++e)n[e]=e;return e.indices=n,e}(e)}return e}function W(e,t){Math.abs(e.y)<s.CesiumMath.EPSILON6&&(e.y=t?-s.CesiumMath.EPSILON6:s.CesiumMath.EPSILON6)}g.compressVertices=function(e){const r=e.attributes.extrudeDirection;let s,o;if(a.defined(r)){const n=r.values;o=n.length/3;const a=new Float32Array(2*o);let u=0;for(s=0;s<o;++s)i.Cartesian3.fromArray(n,3*s,q),i.Cartesian3.equals(q,i.Cartesian3.ZERO)?u+=2:(Z=t.AttributeCompression.octEncodeInRange(q,65535,Z),a[u++]=Z.x,a[u++]=Z.y);return e.attributes.compressedAttributes=new d.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:a}),delete e.attributes.extrudeDirection,e}const u=e.attributes.normal,l=e.attributes.st,p=a.defined(u),f=a.defined(l);if(!p&&!f)return e;const y=e.attributes.tangent,m=e.attributes.bitangent,C=a.defined(y),h=a.defined(m);let v,b,g,A;p&&(v=u.values),f&&(b=l.values),C&&(g=y.values),h&&(A=m.values);o=(p?v.length:b.length)/(p?3:2);let T=o,x=f&&p?2:1;x+=C||h?1:0,T*=x;const P=new Float32Array(T);let w=0;for(s=0;s<o;++s){f&&(n.Cartesian2.fromArray(b,2*s,_),P[w++]=t.AttributeCompression.compressTextureCoordinates(_));const e=3*s;p&&a.defined(g)&&a.defined(A)?(i.Cartesian3.fromArray(v,e,q),i.Cartesian3.fromArray(g,e,U),i.Cartesian3.fromArray(A,e,Y),t.AttributeCompression.octPack(q,U,Y,_),P[w++]=_.x,P[w++]=_.y):(p&&(i.Cartesian3.fromArray(v,e,q),P[w++]=t.AttributeCompression.octEncodeFloat(q)),C&&(i.Cartesian3.fromArray(g,e,q),P[w++]=t.AttributeCompression.octEncodeFloat(q)),h&&(i.Cartesian3.fromArray(A,e,q),P[w++]=t.AttributeCompression.octEncodeFloat(q)))}return e.attributes.compressedAttributes=new d.GeometryAttribute({componentDatatype:c.ComponentDatatype.FLOAT,componentsPerAttribute:x,values:P}),p&&delete e.attributes.normal,f&&delete e.attributes.st,h&&delete e.attributes.bitangent,C&&delete e.attributes.tangent,e};const X=new i.Cartesian3;function j(e,t,n,r){i.Cartesian3.add(e,i.Cartesian3.multiplyByScalar(i.Cartesian3.subtract(t,e,X),e.y/(e.y-t.y),X),n),i.Cartesian3.clone(n,r),W(n,!0),W(r,!1)}const J=new i.Cartesian3,K=new i.Cartesian3,Q=new i.Cartesian3,$=new i.Cartesian3,ee={positions:new Array(7),indices:new Array(9)};function te(e,t,n){if(e.x>=0||t.x>=0||n.x>=0)return;!function(e,t,n){if(0!==e.y&&0!==t.y&&0!==n.y)return W(e,e.y<0),W(t,t.y<0),void W(n,n.y<0);const i=Math.abs(e.y),r=Math.abs(t.y),a=Math.abs(n.y);let o;o=i>r?i>a?s.CesiumMath.sign(e.y):s.CesiumMath.sign(n.y):r>a?s.CesiumMath.sign(t.y):s.CesiumMath.sign(n.y);const u=o<0;W(e,u),W(t,u),W(n,u)}(e,t,n);const i=e.y<0,r=t.y<0,a=n.y<0;let o=0;o+=i?1:0,o+=r?1:0,o+=a?1:0;const u=ee.indices;1===o?(u[1]=3,u[2]=4,u[5]=6,u[7]=6,u[8]=5,i?(j(e,t,J,Q),j(e,n,K,$),u[0]=0,u[3]=1,u[4]=2,u[6]=1):r?(j(t,n,J,Q),j(t,e,K,$),u[0]=1,u[3]=2,u[4]=0,u[6]=2):a&&(j(n,e,J,Q),j(n,t,K,$),u[0]=2,u[3]=0,u[4]=1,u[6]=0)):2===o&&(u[2]=4,u[4]=4,u[5]=3,u[7]=5,u[8]=6,i?r?a||(j(n,e,J,Q),j(n,t,K,$),u[0]=0,u[1]=1,u[3]=0,u[6]=2):(j(t,n,J,Q),j(t,e,K,$),u[0]=2,u[1]=0,u[3]=2,u[6]=1):(j(e,t,J,Q),j(e,n,K,$),u[0]=1,u[1]=2,u[3]=1,u[6]=0));const c=ee.positions;return c[0]=e,c[1]=t,c[2]=n,c.length=3,1!==o&&2!==o||(c[3]=J,c[4]=K,c[5]=Q,c[6]=$,c.length=7),ee}function ne(e,t){const n=e.attributes;if(0===n.position.values.length)return;for(const e in n)if(n.hasOwnProperty(e)&&a.defined(n[e])&&a.defined(n[e].values)){const t=n[e];t.values=c.ComponentDatatype.createTypedArray(t.componentDatatype,t.values)}const i=d.Geometry.computeNumberOfVertices(e);return e.indices=f.IndexDatatype.createTypedArray(i,e.indices),t&&(e.boundingSphere=o.BoundingSphere.fromVertices(n.position.values)),e}function ie(e){const t=e.attributes,n={};for(const e in t)if(t.hasOwnProperty(e)&&a.defined(t[e])&&a.defined(t[e].values)){const i=t[e];n[e]=new d.GeometryAttribute({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return new d.Geometry({attributes:n,indices:[],primitiveType:e.primitiveType})}function re(e,t,n){const i=a.defined(e.geometry.boundingSphere);t=ne(t,i),n=ne(n,i),a.defined(n)&&!a.defined(t)?e.geometry=n:!a.defined(n)&&a.defined(t)?e.geometry=t:(e.westHemisphereGeometry=t,e.eastHemisphereGeometry=n,e.geometry=void 0)}function ae(e,t){const n=new e,i=new e,r=new e;return function(a,s,o,u,c,l,p,d){const f=e.fromArray(c,a*t,n),y=e.fromArray(c,s*t,i),m=e.fromArray(c,o*t,r);e.multiplyByScalar(f,u.x,f),e.multiplyByScalar(y,u.y,y),e.multiplyByScalar(m,u.z,m);const C=e.add(f,y,f);e.add(C,m,C),d&&e.normalize(C,C),e.pack(C,l,p*t)}}const se=ae(n.Cartesian4,4),oe=ae(i.Cartesian3,3),ue=ae(n.Cartesian2,2),ce=new i.Cartesian3,le=new i.Cartesian3,pe=new i.Cartesian3,de=new i.Cartesian3;function fe(e,t,r,o,u,c,l,p,d,f,y,m,b,g,A,T){if(!(a.defined(c)||a.defined(l)||a.defined(p)||a.defined(d)||a.defined(f)||0!==g))return;const x=function(e,t,r,o,u){let c,l,p,d,f,y,m,b;if(a.defined(u)||(u=new i.Cartesian3),a.defined(t.z)){if(i.Cartesian3.equalsEpsilon(e,t,s.CesiumMath.EPSILON14))return i.Cartesian3.clone(i.Cartesian3.UNIT_X,u);if(i.Cartesian3.equalsEpsilon(e,r,s.CesiumMath.EPSILON14))return i.Cartesian3.clone(i.Cartesian3.UNIT_Y,u);if(i.Cartesian3.equalsEpsilon(e,o,s.CesiumMath.EPSILON14))return i.Cartesian3.clone(i.Cartesian3.UNIT_Z,u);c=i.Cartesian3.subtract(r,t,C),l=i.Cartesian3.subtract(o,t,h),p=i.Cartesian3.subtract(e,t,v),d=i.Cartesian3.dot(c,c),f=i.Cartesian3.dot(c,l),y=i.Cartesian3.dot(c,p),m=i.Cartesian3.dot(l,l),b=i.Cartesian3.dot(l,p)}else{if(n.Cartesian2.equalsEpsilon(e,t,s.CesiumMath.EPSILON14))return i.Cartesian3.clone(i.Cartesian3.UNIT_X,u);if(n.Cartesian2.equalsEpsilon(e,r,s.CesiumMath.EPSILON14))return i.Cartesian3.clone(i.Cartesian3.UNIT_Y,u);if(n.Cartesian2.equalsEpsilon(e,o,s.CesiumMath.EPSILON14))return i.Cartesian3.clone(i.Cartesian3.UNIT_Z,u);c=n.Cartesian2.subtract(r,t,C),l=n.Cartesian2.subtract(o,t,h),p=n.Cartesian2.subtract(e,t,v),d=n.Cartesian2.dot(c,c),f=n.Cartesian2.dot(c,l),y=n.Cartesian2.dot(c,p),m=n.Cartesian2.dot(l,l),b=n.Cartesian2.dot(l,p)}u.y=m*y-f*b,u.z=d*b-f*y;const g=d*m-f*f;if(0!==g)return u.y/=g,u.z/=g,u.x=1-u.y-u.z,u}(o,i.Cartesian3.fromArray(u,3*e,ce),i.Cartesian3.fromArray(u,3*t,le),i.Cartesian3.fromArray(u,3*r,pe),de);if(a.defined(x)){if(a.defined(c)&&oe(e,t,r,x,c,m.normal.values,T,!0),a.defined(f)){const n=i.Cartesian3.fromArray(f,3*e,ce),a=i.Cartesian3.fromArray(f,3*t,le),s=i.Cartesian3.fromArray(f,3*r,pe);let o;i.Cartesian3.multiplyByScalar(n,x.x,n),i.Cartesian3.multiplyByScalar(a,x.y,a),i.Cartesian3.multiplyByScalar(s,x.z,s),i.Cartesian3.equals(n,i.Cartesian3.ZERO)&&i.Cartesian3.equals(a,i.Cartesian3.ZERO)&&i.Cartesian3.equals(s,i.Cartesian3.ZERO)?(o=ce,o.x=0,o.y=0,o.z=0):(o=i.Cartesian3.add(n,a,n),i.Cartesian3.add(o,s,o),i.Cartesian3.normalize(o,o)),i.Cartesian3.pack(o,m.extrudeDirection.values,3*T)}if(a.defined(y)&&function(e,t,n,i,r,a,o){const u=r[e]*i.x,c=r[t]*i.y,l=r[n]*i.z;a[o]=u+c+l>s.CesiumMath.EPSILON6?1:0}(e,t,r,x,y,m.applyOffset.values,T),a.defined(l)&&oe(e,t,r,x,l,m.tangent.values,T,!0),a.defined(p)&&oe(e,t,r,x,p,m.bitangent.values,T,!0),a.defined(d)&&ue(e,t,r,x,d,m.st.values,T),g>0)for(let n=0;n<g;n++){const i=b[n];ye(e,t,r,x,T,A[i],m[i])}}}function ye(e,t,n,i,r,a,s){const o=a.componentsPerAttribute,u=a.values,c=s.values;switch(o){case 4:se(e,t,n,i,u,c,r,!1);break;case 3:oe(e,t,n,i,u,c,r,!1);break;case 2:ue(e,t,n,i,u,c,r,!1);break;default:c[r]=u[e]*i.x+u[t]*i.y+u[n]*i.z}}function me(e,t,n,i,r,a){const s=e.position.values.length/3;if(-1!==r){const o=i[r],u=n[o];return-1===u?(n[o]=s,e.position.values.push(a.x,a.y,a.z),t.push(s),s):(t.push(u),u)}return e.position.values.push(a.x,a.y,a.z),t.push(s),s}const Ce={position:!0,normal:!0,bitangent:!0,tangent:!0,st:!0,extrudeDirection:!0,applyOffset:!0};function he(e){const t=e.geometry,n=t.attributes,r=n.position.values,s=a.defined(n.normal)?n.normal.values:void 0,o=a.defined(n.bitangent)?n.bitangent.values:void 0,u=a.defined(n.tangent)?n.tangent.values:void 0,c=a.defined(n.st)?n.st.values:void 0,l=a.defined(n.extrudeDirection)?n.extrudeDirection.values:void 0,p=a.defined(n.applyOffset)?n.applyOffset.values:void 0,d=t.indices,f=[];for(const e in n)n.hasOwnProperty(e)&&!Ce[e]&&a.defined(n[e])&&f.push(e);const y=f.length,m=ie(t),C=ie(t);let h,v,b,g,A;const T=[];T.length=r.length/3;const x=[];for(x.length=r.length/3,A=0;A<T.length;++A)T[A]=-1,x[A]=-1;const P=d.length;for(A=0;A<P;A+=3){const e=d[A],t=d[A+1],P=d[A+2];let w=i.Cartesian3.fromArray(r,3*e),S=i.Cartesian3.fromArray(r,3*t),I=i.Cartesian3.fromArray(r,3*P);const O=te(w,S,I);if(a.defined(O)&&O.positions.length>3){const i=O.positions,a=O.indices,w=a.length;for(let S=0;S<w;++S){const w=a[S],I=i[w];I.y<0?(h=C.attributes,v=C.indices,b=T):(h=m.attributes,v=m.indices,b=x),g=me(h,v,b,d,w<3?A+w:-1,I),fe(e,t,P,I,r,s,u,o,c,l,p,h,f,y,n,g)}}else a.defined(O)&&(w=O.positions[0],S=O.positions[1],I=O.positions[2]),w.y<0?(h=C.attributes,v=C.indices,b=T):(h=m.attributes,v=m.indices,b=x),g=me(h,v,b,d,A,w),fe(e,t,P,w,r,s,u,o,c,l,p,h,f,y,n,g),g=me(h,v,b,d,A+1,S),fe(e,t,P,S,r,s,u,o,c,l,p,h,f,y,n,g),g=me(h,v,b,d,A+2,I),fe(e,t,P,I,r,s,u,o,c,l,p,h,f,y,n,g)}re(e,C,m)}const ve=m.Plane.fromPointNormal(i.Cartesian3.ZERO,i.Cartesian3.UNIT_Y),be=new i.Cartesian3,ge=new i.Cartesian3;function Ae(e,t,n,r,o,u,c){if(!a.defined(c))return;const l=i.Cartesian3.fromArray(r,3*e,ce);i.Cartesian3.equalsEpsilon(l,n,s.CesiumMath.EPSILON10)?u.applyOffset.values[o]=c[e]:u.applyOffset.values[o]=c[t]}function Te(e){const t=e.geometry,n=t.attributes,r=n.position.values,o=a.defined(n.applyOffset)?n.applyOffset.values:void 0,u=t.indices,c=ie(t),l=ie(t);let p;const d=u.length,f=[];f.length=r.length/3;const m=[];for(m.length=r.length/3,p=0;p<f.length;++p)f[p]=-1,m[p]=-1;for(p=0;p<d;p+=2){const e=u[p],t=u[p+1],n=i.Cartesian3.fromArray(r,3*e,ce),d=i.Cartesian3.fromArray(r,3*t,le);let C;Math.abs(n.y)<s.CesiumMath.EPSILON6&&(n.y<0?n.y=-s.CesiumMath.EPSILON6:n.y=s.CesiumMath.EPSILON6),Math.abs(d.y)<s.CesiumMath.EPSILON6&&(d.y<0?d.y=-s.CesiumMath.EPSILON6:d.y=s.CesiumMath.EPSILON6);let h=c.attributes,v=c.indices,b=m,g=l.attributes,A=l.indices,T=f;const x=y.IntersectionTests.lineSegmentPlane(n,d,ve,pe);if(a.defined(x)){const a=i.Cartesian3.multiplyByScalar(i.Cartesian3.UNIT_Y,5*s.CesiumMath.EPSILON9,be);n.y<0&&(i.Cartesian3.negate(a,a),h=l.attributes,v=l.indices,b=f,g=c.attributes,A=c.indices,T=m);const y=i.Cartesian3.add(x,a,ge);C=me(h,v,b,u,p,n),Ae(e,t,n,r,C,h,o),C=me(h,v,b,u,-1,y),Ae(e,t,y,r,C,h,o),i.Cartesian3.negate(a,a),i.Cartesian3.add(x,a,y),C=me(g,A,T,u,-1,y),Ae(e,t,y,r,C,g,o),C=me(g,A,T,u,p+1,d),Ae(e,t,d,r,C,g,o)}else{let i,a,s;n.y<0?(i=l.attributes,a=l.indices,s=f):(i=c.attributes,a=c.indices,s=m),C=me(i,a,s,u,p,n),Ae(e,t,n,r,C,i,o),C=me(i,a,s,u,p+1,d),Ae(e,t,d,r,C,i,o)}}re(e,l,c)}const xe=new n.Cartesian2,Pe=new n.Cartesian2,we=new i.Cartesian3,Se=new i.Cartesian3,Ie=new i.Cartesian3,Oe=new i.Cartesian3,Ee=new i.Cartesian3,Ne=new i.Cartesian3,Le=new n.Cartesian4;function De(e){const t=e.attributes,n=t.position.values,r=t.prevPosition.values,a=t.nextPosition.values,s=n.length;for(let e=0;e<s;e+=3){const t=i.Cartesian3.unpack(n,e,we);if(t.x>0)continue;const o=i.Cartesian3.unpack(r,e,Se);(t.y<0&&o.y>0||t.y>0&&o.y<0)&&(e-3>0?(r[e]=n[e-3],r[e+1]=n[e-2],r[e+2]=n[e-1]):i.Cartesian3.pack(t,r,e));const u=i.Cartesian3.unpack(a,e,Ie);(t.y<0&&u.y>0||t.y>0&&u.y<0)&&(e+3<s?(a[e]=n[e+3],a[e+1]=n[e+4],a[e+2]=n[e+5]):i.Cartesian3.pack(t,a,e))}}const ze=5*s.CesiumMath.EPSILON9,Me=s.CesiumMath.EPSILON6;g.splitLongitude=function(e){const t=e.geometry,r=t.boundingSphere;if(a.defined(r)){if(r.center.x-r.radius>0||o.BoundingSphere.intersectPlane(r,m.Plane.ORIGIN_ZX_PLANE)!==o.Intersect.INTERSECTING)return e}if(t.geometryType!==d.GeometryType.NONE)switch(t.geometryType){case d.GeometryType.POLYLINES:!function(e){const t=e.geometry,r=t.attributes,o=r.position.values,u=r.prevPosition.values,c=r.nextPosition.values,l=r.expandAndWidth.values,p=a.defined(r.st)?r.st.values:void 0,d=a.defined(r.color)?r.color.values:void 0,f=ie(t),m=ie(t);let C,h,v,b=!1;const g=o.length/3;for(C=0;C<g;C+=4){const e=C,t=C+2,r=i.Cartesian3.fromArray(o,3*e,we),g=i.Cartesian3.fromArray(o,3*t,Se);if(Math.abs(r.y)<Me)for(r.y=Me*(g.y<0?-1:1),o[3*C+1]=r.y,o[3*(C+1)+1]=r.y,h=3*e;h<3*e+12;h+=3)u[h]=o[3*C],u[h+1]=o[3*C+1],u[h+2]=o[3*C+2];if(Math.abs(g.y)<Me)for(g.y=Me*(r.y<0?-1:1),o[3*(C+2)+1]=g.y,o[3*(C+3)+1]=g.y,h=3*e;h<3*e+12;h+=3)c[h]=o[3*(C+2)],c[h+1]=o[3*(C+2)+1],c[h+2]=o[3*(C+2)+2];let A=f.attributes,T=f.indices,x=m.attributes,P=m.indices;const w=y.IntersectionTests.lineSegmentPlane(r,g,ve,Oe);if(a.defined(w)){b=!0;const o=i.Cartesian3.multiplyByScalar(i.Cartesian3.UNIT_Y,ze,Ee);r.y<0&&(i.Cartesian3.negate(o,o),A=m.attributes,T=m.indices,x=f.attributes,P=f.indices);const y=i.Cartesian3.add(w,o,Ne);A.position.values.push(r.x,r.y,r.z,r.x,r.y,r.z),A.position.values.push(y.x,y.y,y.z),A.position.values.push(y.x,y.y,y.z),A.prevPosition.values.push(u[3*e],u[3*e+1],u[3*e+2]),A.prevPosition.values.push(u[3*e+3],u[3*e+4],u[3*e+5]),A.prevPosition.values.push(r.x,r.y,r.z,r.x,r.y,r.z),A.nextPosition.values.push(y.x,y.y,y.z),A.nextPosition.values.push(y.x,y.y,y.z),A.nextPosition.values.push(y.x,y.y,y.z),A.nextPosition.values.push(y.x,y.y,y.z),i.Cartesian3.negate(o,o),i.Cartesian3.add(w,o,y),x.position.values.push(y.x,y.y,y.z),x.position.values.push(y.x,y.y,y.z),x.position.values.push(g.x,g.y,g.z,g.x,g.y,g.z),x.prevPosition.values.push(y.x,y.y,y.z),x.prevPosition.values.push(y.x,y.y,y.z),x.prevPosition.values.push(y.x,y.y,y.z),x.prevPosition.values.push(y.x,y.y,y.z),x.nextPosition.values.push(g.x,g.y,g.z,g.x,g.y,g.z),x.nextPosition.values.push(c[3*t],c[3*t+1],c[3*t+2]),x.nextPosition.values.push(c[3*t+3],c[3*t+4],c[3*t+5]);const S=n.Cartesian2.fromArray(l,2*e,xe),I=Math.abs(S.y);A.expandAndWidth.values.push(-1,I,1,I),A.expandAndWidth.values.push(-1,-I,1,-I),x.expandAndWidth.values.push(-1,I,1,I),x.expandAndWidth.values.push(-1,-I,1,-I);let O=i.Cartesian3.magnitudeSquared(i.Cartesian3.subtract(w,r,Ie));if(O/=i.Cartesian3.magnitudeSquared(i.Cartesian3.subtract(g,r,Ie)),a.defined(d)){const i=n.Cartesian4.fromArray(d,4*e,Le),r=n.Cartesian4.fromArray(d,4*t,Le),a=s.CesiumMath.lerp(i.x,r.x,O),o=s.CesiumMath.lerp(i.y,r.y,O),u=s.CesiumMath.lerp(i.z,r.z,O),c=s.CesiumMath.lerp(i.w,r.w,O);for(h=4*e;h<4*e+8;++h)A.color.values.push(d[h]);for(A.color.values.push(a,o,u,c),A.color.values.push(a,o,u,c),x.color.values.push(a,o,u,c),x.color.values.push(a,o,u,c),h=4*t;h<4*t+8;++h)x.color.values.push(d[h])}if(a.defined(p)){const i=n.Cartesian2.fromArray(p,2*e,xe),r=n.Cartesian2.fromArray(p,2*(C+3),Pe),a=s.CesiumMath.lerp(i.x,r.x,O);for(h=2*e;h<2*e+4;++h)A.st.values.push(p[h]);for(A.st.values.push(a,i.y),A.st.values.push(a,r.y),x.st.values.push(a,i.y),x.st.values.push(a,r.y),h=2*t;h<2*t+4;++h)x.st.values.push(p[h])}v=A.position.values.length/3-4,T.push(v,v+2,v+1),T.push(v+1,v+2,v+3),v=x.position.values.length/3-4,P.push(v,v+2,v+1),P.push(v+1,v+2,v+3)}else{let e,t;for(r.y<0?(e=m.attributes,t=m.indices):(e=f.attributes,t=f.indices),e.position.values.push(r.x,r.y,r.z),e.position.values.push(r.x,r.y,r.z),e.position.values.push(g.x,g.y,g.z),e.position.values.push(g.x,g.y,g.z),h=3*C;h<3*C+12;++h)e.prevPosition.values.push(u[h]),e.nextPosition.values.push(c[h]);for(h=2*C;h<2*C+8;++h)e.expandAndWidth.values.push(l[h]),a.defined(p)&&e.st.values.push(p[h]);if(a.defined(d))for(h=4*C;h<4*C+16;++h)e.color.values.push(d[h]);v=e.position.values.length/3-4,t.push(v,v+2,v+1),t.push(v+1,v+2,v+3)}}b&&(De(m),De(f)),re(e,m,f)}(e);break;case d.GeometryType.TRIANGLES:he(e);break;case d.GeometryType.LINES:Te(e)}else H(t),t.primitiveType===d.PrimitiveType.TRIANGLES?he(e):t.primitiveType===d.PrimitiveType.LINES&&Te(e);return e},e.GeometryPipeline=g}));
