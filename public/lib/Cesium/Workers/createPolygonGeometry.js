define(["./defaultValue-f6d5e6da","./Ellipsoid-8e26549b","./ArcType-26a3f38d","./BoundingRectangle-fcba406c","./Transforms-ff941892","./Matrix4-c57ffbd8","./Cartesian3-529c236c","./Cartographic-dbefb6fa","./ComponentDatatype-ab629b88","./EllipsoidGeodesic-8ac7b85d","./EllipsoidTangentPlane-1b5b6a0a","./GeometryAttribute-50e472dc","./GeometryInstance-1d11f88d","./GeometryOffsetAttribute-2579b8d2","./GeometryPipeline-ee4333dd","./IndexDatatype-58eb7805","./Math-355606c6","./Matrix3-31d1f01f","./PolygonGeometryLibrary-687929a2","./PolygonPipeline-c6721c42","./Rectangle-98b0bef0","./VertexFormat-fbdec922","./Interval-d6c8d27a","./DeveloperError-c85858c1","./combine-0c102d93","./RequestType-735c98f2","./RuntimeError-9b4ce3fb","./WebGLConstants-7f557f93","./AxisAlignedBoundingBox-a6aa8040","./IntersectionTests-01432fe7","./Plane-06f34fae","./Matrix2-e4a4609a","./AttributeCompression-d2ca507e","./EncodedCartesian3-94199dac","./arrayRemoveDuplicates-0d8dde26","./EllipsoidRhumbLine-81dc828b","./GeometryAttributes-1e4ddcd2"],(function(t,e,o,r,i,n,a,s,l,u,c,p,y,d,m,g,h,f,b,_,P,C,x,w,T,I,A,v,E,G,O,L,V,H,D,N,F){"use strict";const R=new s.Cartographic,M=new s.Cartographic;function S(t,e,o,r){const i=r.cartesianToCartographic(t,R).height,n=r.cartesianToCartographic(e,M);n.height=i,r.cartographicToCartesian(n,e);const a=r.cartesianToCartographic(o,M);a.height=i-100,r.cartographicToCartesian(a,o)}const B=new r.BoundingRectangle,k=new a.Cartesian3,z=new a.Cartesian3,W=new a.Cartesian3,Y=new a.Cartesian3,U=new a.Cartesian3,j=new a.Cartesian3;let q=new a.Cartesian3,Q=new a.Cartesian3,J=new a.Cartesian3;const K=new n.Cartesian2,Z=new n.Cartesian2,X=new a.Cartesian3,$=new i.Quaternion,tt=new f.Matrix3,et=new f.Matrix3;function ot(e){const o=e.vertexFormat,r=e.geometry,s=e.shadowVolume,u=r.attributes.position.values,c=t.defined(r.attributes.st)?r.attributes.st.values:void 0;let y=u.length;const m=e.wall,g=e.top||m,b=e.bottom||m;if(o.st||o.normal||o.tangent||o.bitangent||s){const d=e.boundingRectangle,_=e.tangentPlane,P=e.ellipsoid,C=e.stRotation,x=e.perPositionHeight,w=K;w.x=d.x,w.y=d.y;const T=o.st?new Float32Array(y/3*2):void 0;let I;o.normal&&(I=x&&g&&!m?r.attributes.normal.values:new Float32Array(y));const A=o.tangent?new Float32Array(y):void 0,v=o.bitangent?new Float32Array(y):void 0,E=s?new Float32Array(y):void 0;let G=0,O=0,L=z,V=W,H=Y,D=!0,N=tt,F=et;if(0!==C){let t=i.Quaternion.fromAxisAngle(_._plane.normal,C,$);N=f.Matrix3.fromQuaternion(t,N),t=i.Quaternion.fromAxisAngle(_._plane.normal,-C,$),F=f.Matrix3.fromQuaternion(t,F)}else N=f.Matrix3.clone(f.Matrix3.IDENTITY,N),F=f.Matrix3.clone(f.Matrix3.IDENTITY,F);let R=0,M=0;g&&b&&(R=y/2,M=y/3,y/=2);for(let r=0;r<y;r+=3){const i=a.Cartesian3.fromArray(u,r,X);if(o.st&&!t.defined(c)){let t=f.Matrix3.multiplyByVector(N,i,k);t=P.scaleToGeodeticSurface(t,t);const e=_.projectPointOntoPlane(t,Z);n.Cartesian2.subtract(e,w,e);const o=h.CesiumMath.clamp(e.x/d.width,0,1),r=h.CesiumMath.clamp(e.y/d.height,0,1);b&&(T[G+M]=o,T[G+1+M]=r),g&&(T[G]=o,T[G+1]=r),G+=2}if(o.normal||o.tangent||o.bitangent||s){const t=O+1,n=O+2;if(m){if(r+3<y){const t=a.Cartesian3.fromArray(u,r+3,U);if(D){const e=a.Cartesian3.fromArray(u,r+y,j);x&&S(i,t,e,P),a.Cartesian3.subtract(t,i,t),a.Cartesian3.subtract(e,i,e),L=a.Cartesian3.normalize(a.Cartesian3.cross(e,t,L),L),D=!1}a.Cartesian3.equalsEpsilon(t,i,h.CesiumMath.EPSILON10)&&(D=!0)}(o.tangent||o.bitangent)&&(H=P.geodeticSurfaceNormal(i,H),o.tangent&&(V=a.Cartesian3.normalize(a.Cartesian3.cross(H,L,V),V)))}else L=P.geodeticSurfaceNormal(i,L),(o.tangent||o.bitangent)&&(x&&(q=a.Cartesian3.fromArray(I,O,q),Q=a.Cartesian3.cross(a.Cartesian3.UNIT_Z,q,Q),Q=a.Cartesian3.normalize(f.Matrix3.multiplyByVector(F,Q,Q),Q),o.bitangent&&(J=a.Cartesian3.normalize(a.Cartesian3.cross(q,Q,J),J))),V=a.Cartesian3.cross(a.Cartesian3.UNIT_Z,L,V),V=a.Cartesian3.normalize(f.Matrix3.multiplyByVector(F,V,V),V),o.bitangent&&(H=a.Cartesian3.normalize(a.Cartesian3.cross(L,V,H),H)));o.normal&&(e.wall?(I[O+R]=L.x,I[t+R]=L.y,I[n+R]=L.z):b&&(I[O+R]=-L.x,I[t+R]=-L.y,I[n+R]=-L.z),(g&&!x||m)&&(I[O]=L.x,I[t]=L.y,I[n]=L.z)),s&&(m&&(L=P.geodeticSurfaceNormal(i,L)),E[O+R]=-L.x,E[t+R]=-L.y,E[n+R]=-L.z),o.tangent&&(e.wall?(A[O+R]=V.x,A[t+R]=V.y,A[n+R]=V.z):b&&(A[O+R]=-V.x,A[t+R]=-V.y,A[n+R]=-V.z),g&&(x?(A[O]=Q.x,A[t]=Q.y,A[n]=Q.z):(A[O]=V.x,A[t]=V.y,A[n]=V.z))),o.bitangent&&(b&&(v[O+R]=H.x,v[t+R]=H.y,v[n+R]=H.z),g&&(x?(v[O]=J.x,v[t]=J.y,v[n]=J.z):(v[O]=H.x,v[t]=H.y,v[n]=H.z))),O+=3}}o.st&&!t.defined(c)&&(r.attributes.st=new p.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:T})),o.normal&&(r.attributes.normal=new p.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:I})),o.tangent&&(r.attributes.tangent=new p.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:A})),o.bitangent&&(r.attributes.bitangent=new p.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:v})),s&&(r.attributes.extrudeDirection=new p.GeometryAttribute({componentDatatype:l.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:E}))}if(e.extrude&&t.defined(e.offsetAttribute)){const t=u.length/3;let o=new Uint8Array(t);if(e.offsetAttribute===d.GeometryOffsetAttribute.TOP)g&&b||m?o=o.fill(1,0,t/2):g&&(o=o.fill(1));else{const t=e.offsetAttribute===d.GeometryOffsetAttribute.NONE?0:1;o=o.fill(t)}r.attributes.applyOffset=new p.GeometryAttribute({componentDatatype:l.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:o})}return r}const rt=new s.Cartographic,it=new s.Cartographic,nt={westOverIDL:0,eastOverIDL:0};let at=new u.EllipsoidGeodesic;function st(e,r,i,n,a){if(a=t.defaultValue(a,new P.Rectangle),!t.defined(e)||e.length<3)return a.west=0,a.north=0,a.south=0,a.east=0,a;if(i===o.ArcType.RHUMB)return P.Rectangle.fromCartesianArray(e,r,a);at.ellipsoid.equals(r)||(at=new u.EllipsoidGeodesic(void 0,void 0,r)),a.west=Number.POSITIVE_INFINITY,a.east=Number.NEGATIVE_INFINITY,a.south=Number.POSITIVE_INFINITY,a.north=Number.NEGATIVE_INFINITY,nt.westOverIDL=Number.POSITIVE_INFINITY,nt.eastOverIDL=Number.NEGATIVE_INFINITY;const s=1/h.CesiumMath.chordLength(n,r.maximumRadius),l=e.length;let c,p=r.cartesianToCartographic(e[0],it),y=rt;for(let t=1;t<l;t++)c=y,y=p,p=r.cartesianToCartographic(e[t],c),at.setEndPoints(y,p),ut(at,s,a,nt);return c=y,y=p,p=r.cartesianToCartographic(e[0],c),at.setEndPoints(y,p),ut(at,s,a,nt),a.east-a.west>nt.eastOverIDL-nt.westOverIDL&&(a.west=nt.westOverIDL,a.east=nt.eastOverIDL,a.east>h.CesiumMath.PI&&(a.east=a.east-h.CesiumMath.TWO_PI),a.west>h.CesiumMath.PI&&(a.west=a.west-h.CesiumMath.TWO_PI)),a}const lt=new s.Cartographic;function ut(t,e,o,r){const i=t.surfaceDistance,n=Math.ceil(i*e),a=n>0?i/(n-1):Number.POSITIVE_INFINITY;let s=0;for(let e=0;e<n;e++){const e=t.interpolateUsingSurfaceDistance(s,lt);s+=a;const i=e.longitude,n=e.latitude;o.west=Math.min(o.west,i),o.east=Math.max(o.east,i),o.south=Math.min(o.south,n),o.north=Math.max(o.north,n);const l=i>=0?i:i+h.CesiumMath.TWO_PI;r.westOverIDL=Math.min(r.westOverIDL,l),r.eastOverIDL=Math.max(r.eastOverIDL,l)}}const ct=[];function pt(e,o,r,i,n,a,s,l,u,p){const d={walls:[]};let m;if(s||l){const n=b.PolygonGeometryLibrary.createGeometryFromPositions(e,o,r,i,a,u,p),c=n.attributes.position.values,h=n.indices;let f,_;if(s&&l){const e=c.concat(c);f=e.length/3,_=g.IndexDatatype.createTypedArray(f,2*h.length),_.set(h);const o=h.length,i=f/2;for(m=0;m<o;m+=3){const t=_[m]+i,e=_[m+1]+i,r=_[m+2]+i;_[m+o]=r,_[m+1+o]=e,_[m+2+o]=t}if(n.attributes.position.values=e,a&&u.normal){const t=n.attributes.normal.values;n.attributes.normal.values=new Float32Array(e.length),n.attributes.normal.values.set(t)}if(u.st&&t.defined(r)){const t=n.attributes.st.values;n.attributes.st.values=new Float32Array(2*f),n.attributes.st.values=t.concat(t)}n.indices=_}else if(l){for(f=c.length/3,_=g.IndexDatatype.createTypedArray(f,h.length),m=0;m<h.length;m+=3)_[m]=h[m+2],_[m+1]=h[m+1],_[m+2]=h[m];n.indices=_}d.topAndBottom=new y.GeometryInstance({geometry:n})}let h=n.outerRing,f=c.EllipsoidTangentPlane.fromPoints(h,e),P=f.projectPointsOntoPlane(h,ct),C=_.PolygonPipeline.computeWindingOrder2D(P);C===_.WindingOrder.CLOCKWISE&&(h=h.slice().reverse());let x=b.PolygonGeometryLibrary.computeWallGeometry(h,r,e,i,a,p);d.walls.push(new y.GeometryInstance({geometry:x}));const w=n.holes;for(m=0;m<w.length;m++){let t=w[m];f=c.EllipsoidTangentPlane.fromPoints(t,e),P=f.projectPointsOntoPlane(t,ct),C=_.PolygonPipeline.computeWindingOrder2D(P),C===_.WindingOrder.COUNTER_CLOCKWISE&&(t=t.slice().reverse()),x=b.PolygonGeometryLibrary.computeWallGeometry(t,r,e,i,a,p),d.walls.push(new y.GeometryInstance({geometry:x}))}return d}function yt(r){const i=r.polygonHierarchy,s=t.defaultValue(r.vertexFormat,C.VertexFormat.DEFAULT),l=t.defaultValue(r.ellipsoid,e.Ellipsoid.WGS84),u=t.defaultValue(r.granularity,h.CesiumMath.RADIANS_PER_DEGREE),c=t.defaultValue(r.stRotation,0),p=r.textureCoordinates,y=t.defaultValue(r.perPositionHeight,!1),d=y&&t.defined(r.extrudedHeight);let m=t.defaultValue(r.height,0),g=t.defaultValue(r.extrudedHeight,m);if(!d){const t=Math.max(m,g);g=Math.min(m,g),m=t}this._vertexFormat=C.VertexFormat.clone(s),this._ellipsoid=e.Ellipsoid.clone(l),this._granularity=u,this._stRotation=c,this._height=m,this._extrudedHeight=g,this._closeTop=t.defaultValue(r.closeTop,!0),this._closeBottom=t.defaultValue(r.closeBottom,!0),this._polygonHierarchy=i,this._perPositionHeight=y,this._perPositionHeightExtrude=d,this._shadowVolume=t.defaultValue(r.shadowVolume,!1),this._workerName="createPolygonGeometry",this._offsetAttribute=r.offsetAttribute,this._arcType=t.defaultValue(r.arcType,o.ArcType.GEODESIC),this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0,this._textureCoordinates=p,this.packedLength=b.PolygonGeometryLibrary.computeHierarchyPackedLength(i,a.Cartesian3)+e.Ellipsoid.packedLength+C.VertexFormat.packedLength+(p?b.PolygonGeometryLibrary.computeHierarchyPackedLength(p,n.Cartesian2):1)+12}yt.fromPositions=function(e){return new yt({polygonHierarchy:{positions:(e=t.defaultValue(e,t.defaultValue.EMPTY_OBJECT)).positions},height:e.height,extrudedHeight:e.extrudedHeight,vertexFormat:e.vertexFormat,stRotation:e.stRotation,ellipsoid:e.ellipsoid,granularity:e.granularity,perPositionHeight:e.perPositionHeight,closeTop:e.closeTop,closeBottom:e.closeBottom,offsetAttribute:e.offsetAttribute,arcType:e.arcType,textureCoordinates:e.textureCoordinates})},yt.pack=function(o,r,i){return i=t.defaultValue(i,0),i=b.PolygonGeometryLibrary.packPolygonHierarchy(o._polygonHierarchy,r,i,a.Cartesian3),e.Ellipsoid.pack(o._ellipsoid,r,i),i+=e.Ellipsoid.packedLength,C.VertexFormat.pack(o._vertexFormat,r,i),i+=C.VertexFormat.packedLength,r[i++]=o._height,r[i++]=o._extrudedHeight,r[i++]=o._granularity,r[i++]=o._stRotation,r[i++]=o._perPositionHeightExtrude?1:0,r[i++]=o._perPositionHeight?1:0,r[i++]=o._closeTop?1:0,r[i++]=o._closeBottom?1:0,r[i++]=o._shadowVolume?1:0,r[i++]=t.defaultValue(o._offsetAttribute,-1),r[i++]=o._arcType,t.defined(o._textureCoordinates)?i=b.PolygonGeometryLibrary.packPolygonHierarchy(o._textureCoordinates,r,i,n.Cartesian2):r[i++]=-1,r[i++]=o.packedLength,r};const dt=e.Ellipsoid.clone(e.Ellipsoid.UNIT_SPHERE),mt=new C.VertexFormat,gt={polygonHierarchy:{}};return yt.unpack=function(o,r,i){r=t.defaultValue(r,0);const s=b.PolygonGeometryLibrary.unpackPolygonHierarchy(o,r,a.Cartesian3);r=s.startingIndex,delete s.startingIndex;const l=e.Ellipsoid.unpack(o,r,dt);r+=e.Ellipsoid.packedLength;const u=C.VertexFormat.unpack(o,r,mt);r+=C.VertexFormat.packedLength;const c=o[r++],p=o[r++],y=o[r++],d=o[r++],m=1===o[r++],g=1===o[r++],h=1===o[r++],f=1===o[r++],_=1===o[r++],P=o[r++],x=o[r++],w=-1===o[r]?void 0:b.PolygonGeometryLibrary.unpackPolygonHierarchy(o,r,n.Cartesian2);t.defined(w)?(r=w.startingIndex,delete w.startingIndex):r++;const T=o[r++];return t.defined(i)||(i=new yt(gt)),i._polygonHierarchy=s,i._ellipsoid=e.Ellipsoid.clone(l,i._ellipsoid),i._vertexFormat=C.VertexFormat.clone(u,i._vertexFormat),i._height=c,i._extrudedHeight=p,i._granularity=y,i._stRotation=d,i._perPositionHeightExtrude=m,i._perPositionHeight=g,i._closeTop=h,i._closeBottom=f,i._shadowVolume=_,i._offsetAttribute=-1===P?void 0:P,i._arcType=x,i._textureCoordinates=w,i.packedLength=T,i},yt.computeRectangle=function(r,i){const n=t.defaultValue(r.granularity,h.CesiumMath.RADIANS_PER_DEGREE),a=t.defaultValue(r.arcType,o.ArcType.GEODESIC),s=r.polygonHierarchy,l=t.defaultValue(r.ellipsoid,e.Ellipsoid.WGS84);return st(s.positions,l,a,n,i)},yt.createGeometry=function(e){const o=e._vertexFormat,r=e._ellipsoid,n=e._granularity,a=e._stRotation,s=e._polygonHierarchy,u=e._perPositionHeight,f=e._closeTop,P=e._closeBottom,C=e._arcType,x=e._textureCoordinates,w=t.defined(x);let T=s.positions;if(T.length<3)return;const I=c.EllipsoidTangentPlane.fromPoints(T,r),A=b.PolygonGeometryLibrary.polygonsFromHierarchy(s,w,I.projectPointsOntoPlane.bind(I),!u,r),v=A.hierarchy,E=A.polygons,G=w?b.PolygonGeometryLibrary.polygonsFromHierarchy(x,!0,(function(t){return t}),!1).polygons:void 0;if(0===v.length)return;T=v[0].outerRing;const O=b.PolygonGeometryLibrary.computeBoundingRectangle(I.plane.normal,I.projectPointOntoPlane.bind(I),T,a,B),L=[],V=e._height,H=e._extrudedHeight,D={perPositionHeight:u,vertexFormat:o,geometry:void 0,tangentPlane:I,boundingRectangle:O,ellipsoid:r,stRotation:a,textureCoordinates:void 0,bottom:!1,top:!0,wall:!1,extrude:!1,arcType:C};let N;if(e._perPositionHeightExtrude||!h.CesiumMath.equalsEpsilon(V,H,0,h.CesiumMath.EPSILON2))for(D.extrude=!0,D.top=f,D.bottom=P,D.shadowVolume=e._shadowVolume,D.offsetAttribute=e._offsetAttribute,N=0;N<E.length;N++){const t=pt(r,E[N],w?G[N]:void 0,n,v[N],u,f,P,o,C);let e;f&&P?(e=t.topAndBottom,D.geometry=b.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(e.geometry,V,H,r,u)):f?(e=t.topAndBottom,e.geometry.attributes.position.values=_.PolygonPipeline.scaleToGeodeticHeight(e.geometry.attributes.position.values,V,r,!u),D.geometry=e.geometry):P&&(e=t.topAndBottom,e.geometry.attributes.position.values=_.PolygonPipeline.scaleToGeodeticHeight(e.geometry.attributes.position.values,H,r,!0),D.geometry=e.geometry),(f||P)&&(D.wall=!1,e.geometry=ot(D),L.push(e));const i=t.walls;D.wall=!0;for(let t=0;t<i.length;t++){const e=i[t];D.geometry=b.PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(e.geometry,V,H,r,u),e.geometry=ot(D),L.push(e)}}else for(N=0;N<E.length;N++){const i=new y.GeometryInstance({geometry:b.PolygonGeometryLibrary.createGeometryFromPositions(r,E[N],w?G[N]:void 0,n,u,o,C)});if(i.geometry.attributes.position.values=_.PolygonPipeline.scaleToGeodeticHeight(i.geometry.attributes.position.values,V,r,!u),D.geometry=i.geometry,i.geometry=ot(D),t.defined(e._offsetAttribute)){const t=i.geometry.attributes.position.values.length,o=e._offsetAttribute===d.GeometryOffsetAttribute.NONE?0:1,r=new Uint8Array(t/3).fill(o);i.geometry.attributes.applyOffset=new p.GeometryAttribute({componentDatatype:l.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}L.push(i)}const F=m.GeometryPipeline.combineInstances(L)[0];F.attributes.position.values=new Float64Array(F.attributes.position.values),F.indices=g.IndexDatatype.createTypedArray(F.attributes.position.values.length/3,F.indices);const R=F.attributes,M=i.BoundingSphere.fromVertices(R.position.values);return o.position||delete R.position,new p.Geometry({attributes:R,indices:F.indices,primitiveType:F.primitiveType,boundingSphere:M,offsetAttribute:e._offsetAttribute})},yt.createShadowVolume=function(t,e,o){const r=t._granularity,i=t._ellipsoid,n=e(r,i),a=o(r,i);return new yt({polygonHierarchy:t._polygonHierarchy,ellipsoid:i,stRotation:t._stRotation,granularity:r,perPositionHeight:!1,extrudedHeight:n,height:a,vertexFormat:C.VertexFormat.POSITION_ONLY,shadowVolume:!0,arcType:t._arcType})},Object.defineProperties(yt.prototype,{rectangle:{get:function(){if(!t.defined(this._rectangle)){const t=this._polygonHierarchy.positions;this._rectangle=st(t,this._ellipsoid,this._arcType,this._granularity)}return this._rectangle}},textureCoordinateRotationPoints:{get:function(){return t.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=function(t){const e=-t._stRotation;if(0===e)return[0,0,0,1,1,0];const o=t._ellipsoid,r=t._polygonHierarchy.positions,i=t.rectangle;return p.Geometry._textureCoordinateRotationPoints(r,e,o,i)}(this)),this._textureCoordinateRotationPoints}}}),function(o,r){return t.defined(r)&&(o=yt.unpack(o,r)),o._ellipsoid=e.Ellipsoid.clone(o._ellipsoid),yt.createGeometry(o)}}));
