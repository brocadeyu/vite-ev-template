/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.96
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
define(["exports","./Cartographic-de64a93a","./Check-d82b20f7","./defaultValue-4607806f","./Cartesian3-2da9bb0a","./DeveloperError-46384437","./Math-6bc63320"],(function(t,e,a,i,n,r,o){"use strict";function u(t,e,a,r){e=i.defaultValue(e,0),a=i.defaultValue(a,0),r=i.defaultValue(r,0),t._radii=new n.Cartesian3(e,a,r),t._radiiSquared=new n.Cartesian3(e*e,a*a,r*r),t._radiiToTheFourth=new n.Cartesian3(e*e*e*e,a*a*a*a,r*r*r*r),t._oneOverRadii=new n.Cartesian3(0===e?0:1/e,0===a?0:1/a,0===r?0:1/r),t._oneOverRadiiSquared=new n.Cartesian3(0===e?0:1/(e*e),0===a?0:1/(a*a),0===r?0:1/(r*r)),t._minimumRadius=Math.min(e,a,r),t._maximumRadius=Math.max(e,a,r),t._centerToleranceSquared=o.CesiumMath.EPSILON1,0!==t._radiiSquared.z&&(t._squaredXOverSquaredZ=t._radiiSquared.x/t._radiiSquared.z)}function s(t,e,a){this._radii=void 0,this._radiiSquared=void 0,this._radiiToTheFourth=void 0,this._oneOverRadii=void 0,this._oneOverRadiiSquared=void 0,this._minimumRadius=void 0,this._maximumRadius=void 0,this._centerToleranceSquared=void 0,this._squaredXOverSquaredZ=void 0,u(this,t,e,a)}Object.defineProperties(s.prototype,{radii:{get:function(){return this._radii}},radiiSquared:{get:function(){return this._radiiSquared}},radiiToTheFourth:{get:function(){return this._radiiToTheFourth}},oneOverRadii:{get:function(){return this._oneOverRadii}},oneOverRadiiSquared:{get:function(){return this._oneOverRadiiSquared}},minimumRadius:{get:function(){return this._minimumRadius}},maximumRadius:{get:function(){return this._maximumRadius}}}),s.clone=function(t,e){if(!i.defined(t))return;const a=t._radii;return i.defined(e)?(n.Cartesian3.clone(a,e._radii),n.Cartesian3.clone(t._radiiSquared,e._radiiSquared),n.Cartesian3.clone(t._radiiToTheFourth,e._radiiToTheFourth),n.Cartesian3.clone(t._oneOverRadii,e._oneOverRadii),n.Cartesian3.clone(t._oneOverRadiiSquared,e._oneOverRadiiSquared),e._minimumRadius=t._minimumRadius,e._maximumRadius=t._maximumRadius,e._centerToleranceSquared=t._centerToleranceSquared,e):new s(a.x,a.y,a.z)},s.fromCartesian3=function(t,e){return i.defined(e)||(e=new s),i.defined(t)?(u(e,t.x,t.y,t.z),e):e},s.WGS84=Object.freeze(new s(6378137,6378137,6356752.314140356)),s.UNIT_SPHERE=Object.freeze(new s(1,1,1)),s.MOON=Object.freeze(new s(o.CesiumMath.LUNAR_RADIUS,o.CesiumMath.LUNAR_RADIUS,o.CesiumMath.LUNAR_RADIUS)),s.prototype.clone=function(t){return s.clone(this,t)},s.packedLength=n.Cartesian3.packedLength,s.pack=function(t,e,a){return a=i.defaultValue(a,0),n.Cartesian3.pack(t._radii,e,a),e},s.unpack=function(t,e,a){e=i.defaultValue(e,0);const r=n.Cartesian3.unpack(t,e);return s.fromCartesian3(r,a)},s.prototype.geocentricSurfaceNormal=n.Cartesian3.normalize,s.prototype.geodeticSurfaceNormalCartographic=function(t,e){const a=t.longitude,r=t.latitude,o=Math.cos(r),u=o*Math.cos(a),s=o*Math.sin(a),h=Math.sin(r);return i.defined(e)||(e=new n.Cartesian3),e.x=u,e.y=s,e.z=h,n.Cartesian3.normalize(e,e)},s.prototype.geodeticSurfaceNormal=function(t,e){if(!n.Cartesian3.equalsEpsilon(t,n.Cartesian3.ZERO,o.CesiumMath.EPSILON14))return i.defined(e)||(e=new n.Cartesian3),e=n.Cartesian3.multiplyComponents(t,this._oneOverRadiiSquared,e),n.Cartesian3.normalize(e,e)};const h=new n.Cartesian3,d=new n.Cartesian3;s.prototype.cartographicToCartesian=function(t,e){const a=h,r=d;this.geodeticSurfaceNormalCartographic(t,a),n.Cartesian3.multiplyComponents(this._radiiSquared,a,r);const o=Math.sqrt(n.Cartesian3.dot(a,r));return n.Cartesian3.divideByScalar(r,o,r),n.Cartesian3.multiplyByScalar(a,t.height,a),i.defined(e)||(e=new n.Cartesian3),n.Cartesian3.add(r,a,e)},s.prototype.cartographicArrayToCartesianArray=function(t,e){const a=t.length;i.defined(e)?e.length=a:e=new Array(a);for(let i=0;i<a;i++)e[i]=this.cartographicToCartesian(t[i],e[i]);return e};const c=new n.Cartesian3,l=new n.Cartesian3,f=new n.Cartesian3;s.prototype.cartesianToCartographic=function(t,a){const r=this.scaleToGeodeticSurface(t,l);if(!i.defined(r))return;const u=this.geodeticSurfaceNormal(r,c),s=n.Cartesian3.subtract(t,r,f),h=Math.atan2(u.y,u.x),d=Math.asin(u.z),m=o.CesiumMath.sign(n.Cartesian3.dot(s,t))*n.Cartesian3.magnitude(s);return i.defined(a)?(a.longitude=h,a.latitude=d,a.height=m,a):new e.Cartographic(h,d,m)},s.prototype.cartesianArrayToCartographicArray=function(t,e){const a=t.length;i.defined(e)?e.length=a:e=new Array(a);for(let i=0;i<a;++i)e[i]=this.cartesianToCartographic(t[i],e[i]);return e},s.prototype.scaleToGeodeticSurface=function(t,a){return e.scaleToGeodeticSurface(t,this._oneOverRadii,this._oneOverRadiiSquared,this._centerToleranceSquared,a)},s.prototype.scaleToGeocentricSurface=function(t,e){i.defined(e)||(e=new n.Cartesian3);const a=t.x,r=t.y,o=t.z,u=this._oneOverRadiiSquared,s=1/Math.sqrt(a*a*u.x+r*r*u.y+o*o*u.z);return n.Cartesian3.multiplyByScalar(t,s,e)},s.prototype.transformPositionToScaledSpace=function(t,e){return i.defined(e)||(e=new n.Cartesian3),n.Cartesian3.multiplyComponents(t,this._oneOverRadii,e)},s.prototype.transformPositionFromScaledSpace=function(t,e){return i.defined(e)||(e=new n.Cartesian3),n.Cartesian3.multiplyComponents(t,this._radii,e)},s.prototype.equals=function(t){return this===t||i.defined(t)&&n.Cartesian3.equals(this._radii,t._radii)},s.prototype.toString=function(){return this._radii.toString()},s.prototype.getSurfaceNormalIntersectionWithZAxis=function(t,e,a){e=i.defaultValue(e,0);const r=this._squaredXOverSquaredZ;if(i.defined(a)||(a=new n.Cartesian3),a.x=0,a.y=0,a.z=t.z*(1-r),!(Math.abs(a.z)>=this._radii.z-e))return a};const m=[.14887433898163,.43339539412925,.67940956829902,.86506336668898,.97390652851717,0],C=[.29552422471475,.26926671930999,.21908636251598,.14945134915058,.066671344308684,0];function M(t,e,a){const i=.5*(e+t),n=.5*(e-t);let r=0;for(let t=0;t<5;t++){const e=n*m[t];r+=C[t]*(a(i+e)+a(i-e))}return r*=n,r}function p(t,e,a,n){this.west=i.defaultValue(t,0),this.south=i.defaultValue(e,0),this.east=i.defaultValue(a,0),this.north=i.defaultValue(n,0)}s.prototype.surfaceArea=function(t){const e=t.west;let a=t.east;const i=t.south,n=t.north;for(;a<e;)a+=o.CesiumMath.TWO_PI;const r=this._radiiSquared,u=r.x,s=r.y,h=r.z,d=u*s;return M(i,n,(function(t){const i=Math.cos(t),n=Math.sin(t);return Math.cos(t)*M(e,a,(function(t){const e=Math.cos(t),a=Math.sin(t);return Math.sqrt(d*n*n+h*(s*e*e+u*a*a)*i*i)}))}))},Object.defineProperties(p.prototype,{width:{get:function(){return p.computeWidth(this)}},height:{get:function(){return p.computeHeight(this)}}}),p.packedLength=4,p.pack=function(t,e,a){return a=i.defaultValue(a,0),e[a++]=t.west,e[a++]=t.south,e[a++]=t.east,e[a]=t.north,e},p.unpack=function(t,e,a){return e=i.defaultValue(e,0),i.defined(a)||(a=new p),a.west=t[e++],a.south=t[e++],a.east=t[e++],a.north=t[e],a},p.computeWidth=function(t){let e=t.east;const a=t.west;return e<a&&(e+=o.CesiumMath.TWO_PI),e-a},p.computeHeight=function(t){return t.north-t.south},p.fromDegrees=function(t,e,a,n,r){return t=o.CesiumMath.toRadians(i.defaultValue(t,0)),e=o.CesiumMath.toRadians(i.defaultValue(e,0)),a=o.CesiumMath.toRadians(i.defaultValue(a,0)),n=o.CesiumMath.toRadians(i.defaultValue(n,0)),i.defined(r)?(r.west=t,r.south=e,r.east=a,r.north=n,r):new p(t,e,a,n)},p.fromRadians=function(t,e,a,n,r){return i.defined(r)?(r.west=i.defaultValue(t,0),r.south=i.defaultValue(e,0),r.east=i.defaultValue(a,0),r.north=i.defaultValue(n,0),r):new p(t,e,a,n)},p.fromCartographicArray=function(t,e){let a=Number.MAX_VALUE,n=-Number.MAX_VALUE,r=Number.MAX_VALUE,u=-Number.MAX_VALUE,s=Number.MAX_VALUE,h=-Number.MAX_VALUE;for(let e=0,i=t.length;e<i;e++){const i=t[e];a=Math.min(a,i.longitude),n=Math.max(n,i.longitude),s=Math.min(s,i.latitude),h=Math.max(h,i.latitude);const d=i.longitude>=0?i.longitude:i.longitude+o.CesiumMath.TWO_PI;r=Math.min(r,d),u=Math.max(u,d)}return n-a>u-r&&(a=r,n=u,n>o.CesiumMath.PI&&(n-=o.CesiumMath.TWO_PI),a>o.CesiumMath.PI&&(a-=o.CesiumMath.TWO_PI)),i.defined(e)?(e.west=a,e.south=s,e.east=n,e.north=h,e):new p(a,s,n,h)},p.fromCartesianArray=function(t,e,a){e=i.defaultValue(e,s.WGS84);let n=Number.MAX_VALUE,r=-Number.MAX_VALUE,u=Number.MAX_VALUE,h=-Number.MAX_VALUE,d=Number.MAX_VALUE,c=-Number.MAX_VALUE;for(let a=0,i=t.length;a<i;a++){const i=e.cartesianToCartographic(t[a]);n=Math.min(n,i.longitude),r=Math.max(r,i.longitude),d=Math.min(d,i.latitude),c=Math.max(c,i.latitude);const s=i.longitude>=0?i.longitude:i.longitude+o.CesiumMath.TWO_PI;u=Math.min(u,s),h=Math.max(h,s)}return r-n>h-u&&(n=u,r=h,r>o.CesiumMath.PI&&(r-=o.CesiumMath.TWO_PI),n>o.CesiumMath.PI&&(n-=o.CesiumMath.TWO_PI)),i.defined(a)?(a.west=n,a.south=d,a.east=r,a.north=c,a):new p(n,d,r,c)},p.clone=function(t,e){if(i.defined(t))return i.defined(e)?(e.west=t.west,e.south=t.south,e.east=t.east,e.north=t.north,e):new p(t.west,t.south,t.east,t.north)},p.equalsEpsilon=function(t,e,a){return a=i.defaultValue(a,0),t===e||i.defined(t)&&i.defined(e)&&Math.abs(t.west-e.west)<=a&&Math.abs(t.south-e.south)<=a&&Math.abs(t.east-e.east)<=a&&Math.abs(t.north-e.north)<=a},p.prototype.clone=function(t){return p.clone(this,t)},p.prototype.equals=function(t){return p.equals(this,t)},p.equals=function(t,e){return t===e||i.defined(t)&&i.defined(e)&&t.west===e.west&&t.south===e.south&&t.east===e.east&&t.north===e.north},p.prototype.equalsEpsilon=function(t,e){return p.equalsEpsilon(this,t,e)},p.validate=function(t){},p.southwest=function(t,a){return i.defined(a)?(a.longitude=t.west,a.latitude=t.south,a.height=0,a):new e.Cartographic(t.west,t.south)},p.northwest=function(t,a){return i.defined(a)?(a.longitude=t.west,a.latitude=t.north,a.height=0,a):new e.Cartographic(t.west,t.north)},p.northeast=function(t,a){return i.defined(a)?(a.longitude=t.east,a.latitude=t.north,a.height=0,a):new e.Cartographic(t.east,t.north)},p.southeast=function(t,a){return i.defined(a)?(a.longitude=t.east,a.latitude=t.south,a.height=0,a):new e.Cartographic(t.east,t.south)},p.center=function(t,a){let n=t.east;const r=t.west;n<r&&(n+=o.CesiumMath.TWO_PI);const u=o.CesiumMath.negativePiToPi(.5*(r+n)),s=.5*(t.south+t.north);return i.defined(a)?(a.longitude=u,a.latitude=s,a.height=0,a):new e.Cartographic(u,s)},p.intersection=function(t,e,a){let n=t.east,r=t.west,u=e.east,s=e.west;n<r&&u>0?n+=o.CesiumMath.TWO_PI:u<s&&n>0&&(u+=o.CesiumMath.TWO_PI),n<r&&s<0?s+=o.CesiumMath.TWO_PI:u<s&&r<0&&(r+=o.CesiumMath.TWO_PI);const h=o.CesiumMath.negativePiToPi(Math.max(r,s)),d=o.CesiumMath.negativePiToPi(Math.min(n,u));if((t.west<t.east||e.west<e.east)&&d<=h)return;const c=Math.max(t.south,e.south),l=Math.min(t.north,e.north);return c>=l?void 0:i.defined(a)?(a.west=h,a.south=c,a.east=d,a.north=l,a):new p(h,c,d,l)},p.simpleIntersection=function(t,e,a){const n=Math.max(t.west,e.west),r=Math.max(t.south,e.south),o=Math.min(t.east,e.east),u=Math.min(t.north,e.north);if(!(r>=u||n>=o))return i.defined(a)?(a.west=n,a.south=r,a.east=o,a.north=u,a):new p(n,r,o,u)},p.union=function(t,e,a){i.defined(a)||(a=new p);let n=t.east,r=t.west,u=e.east,s=e.west;n<r&&u>0?n+=o.CesiumMath.TWO_PI:u<s&&n>0&&(u+=o.CesiumMath.TWO_PI),n<r&&s<0?s+=o.CesiumMath.TWO_PI:u<s&&r<0&&(r+=o.CesiumMath.TWO_PI);const h=o.CesiumMath.negativePiToPi(Math.min(r,s)),d=o.CesiumMath.negativePiToPi(Math.max(n,u));return a.west=h,a.south=Math.min(t.south,e.south),a.east=d,a.north=Math.max(t.north,e.north),a},p.expand=function(t,e,a){return i.defined(a)||(a=new p),a.west=Math.min(t.west,e.longitude),a.south=Math.min(t.south,e.latitude),a.east=Math.max(t.east,e.longitude),a.north=Math.max(t.north,e.latitude),a},p.contains=function(t,e){let a=e.longitude;const i=e.latitude,n=t.west;let r=t.east;return r<n&&(r+=o.CesiumMath.TWO_PI,a<0&&(a+=o.CesiumMath.TWO_PI)),(a>n||o.CesiumMath.equalsEpsilon(a,n,o.CesiumMath.EPSILON14))&&(a<r||o.CesiumMath.equalsEpsilon(a,r,o.CesiumMath.EPSILON14))&&i>=t.south&&i<=t.north};const _=new e.Cartographic;p.subsample=function(t,e,a,n){e=i.defaultValue(e,s.WGS84),a=i.defaultValue(a,0),i.defined(n)||(n=[]);let r=0;const u=t.north,h=t.south,d=t.east,c=t.west,l=_;l.height=a,l.longitude=c,l.latitude=u,n[r]=e.cartographicToCartesian(l,n[r]),r++,l.longitude=d,n[r]=e.cartographicToCartesian(l,n[r]),r++,l.latitude=h,n[r]=e.cartographicToCartesian(l,n[r]),r++,l.longitude=c,n[r]=e.cartographicToCartesian(l,n[r]),r++,l.latitude=u<0?u:h>0?h:0;for(let a=1;a<8;++a)l.longitude=-Math.PI+a*o.CesiumMath.PI_OVER_TWO,p.contains(t,l)&&(n[r]=e.cartographicToCartesian(l,n[r]),r++);return 0===l.latitude&&(l.longitude=c,n[r]=e.cartographicToCartesian(l,n[r]),r++,l.longitude=d,n[r]=e.cartographicToCartesian(l,n[r]),r++),n.length=r,n},p.subsection=function(t,e,a,n,r,u){if(i.defined(u)||(u=new p),t.west<=t.east){const a=t.east-t.west;u.west=t.west+e*a,u.east=t.west+n*a}else{const a=o.CesiumMath.TWO_PI+t.east-t.west;u.west=o.CesiumMath.negativePiToPi(t.west+e*a),u.east=o.CesiumMath.negativePiToPi(t.west+n*a)}const s=t.north-t.south;return u.south=t.south+a*s,u.north=t.south+r*s,1===e&&(u.west=t.east),1===n&&(u.east=t.east),1===a&&(u.south=t.north),1===r&&(u.north=t.north),u},p.MAX_VALUE=Object.freeze(new p(-Math.PI,-o.CesiumMath.PI_OVER_TWO,Math.PI,o.CesiumMath.PI_OVER_TWO)),t.Ellipsoid=s,t.Rectangle=p}));
